// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`AsyncSelectFilter generates field with filter 1`] = `
"
    import { FormattedMessage } from "react-intl";
import { useApolloClient } from "@apollo/client";
import { useQuery } from "@apollo/client";
import { gql } from "@apollo/client";
import { CheckboxField } from "@comet/admin";
import { Field } from "@comet/admin";
import { filterByFragment } from "@comet/admin";
import { FinalForm } from "@comet/admin";
import { FinalFormInput } from "@comet/admin";
import { FinalFormRangeInput } from "@comet/admin";
import { FinalFormSelect } from "@comet/admin";
import { FinalFormSubmitEvent } from "@comet/admin";
import { Loading } from "@comet/admin";
import { NumberField } from "@comet/admin";
import { RadioGroupField } from "@comet/admin";
import { TextAreaField } from "@comet/admin";
import { TextField } from "@comet/admin";
import { useFormApiRef } from "@comet/admin";
import { useStackSwitchApi } from "@comet/admin";
import { ArrowLeft } from "@comet/admin-icons";
import { Lock } from "@comet/admin-icons";
import { DateTimeField } from "@comet/admin-date-time";
import { FinalFormDatePicker } from "@comet/admin-date-time";
import { BlockState } from "@comet/cms-admin";
import { createFinalFormBlock } from "@comet/cms-admin";
import { queryUpdatedAt } from "@comet/cms-admin";
import { resolveHasSaveConflict } from "@comet/cms-admin";
import { useFormSaveConflict } from "@comet/cms-admin";
import { FileUploadField } from "@comet/cms-admin";
import { IconButton } from "@mui/material";
import { MenuItem } from "@mui/material";
import { InputAdornment } from "@mui/material";
import { FormApi } from "final-form";
import { useMemo } from "react";
import { GQLProductCategoriesSelectQuery } from "./ProductHighlightForm.generated";
import { GQLProductCategoriesSelectQueryVariables } from "./ProductHighlightForm.generated";
import { AsyncSelectField } from "@comet/admin";
import { OnChangeField } from "@comet/admin";
import { GQLProductsSelectQuery } from "./ProductHighlightForm.generated";
import { GQLProductsSelectQueryVariables } from "./ProductHighlightForm.generated";
import { productHighlightFormFragment } from "./ProductHighlightForm.gql";
import { GQLProductHighlightFormFragment } from "./ProductHighlightForm.gql.generated";
import { productHighlightQuery } from "./ProductHighlightForm.gql";
import { GQLProductHighlightQuery } from "./ProductHighlightForm.gql.generated";
import { GQLProductHighlightQueryVariables } from "./ProductHighlightForm.gql.generated";
import { createProductHighlightMutation } from "./ProductHighlightForm.gql";
import { GQLCreateProductHighlightMutation } from "./ProductHighlightForm.gql.generated";
import { GQLCreateProductHighlightMutationVariables } from "./ProductHighlightForm.gql.generated";
import { updateProductHighlightMutation } from "./ProductHighlightForm.gql";
import { GQLUpdateProductHighlightMutation } from "./ProductHighlightForm.gql.generated";
import { GQLUpdateProductHighlightMutationVariables } from "./ProductHighlightForm.gql.generated";
    import isEqual from "lodash.isequal";

    

    

    type FormValues = GQLProductHighlightFormFragment & {
                productCategory?: { id: string; title: string };
            };

    interface FormProps {
            id?: string;
        }

    export function ProductHighlightForm({id}: FormProps) {
        const client = useApolloClient();
        const mode = id ? "edit" : "add";
        const formApiRef = useFormApiRef<FormValues>();
        const stackSwitchApi = useStackSwitchApi();

        
        const { data, error, loading, refetch } = useQuery<GQLProductHighlightQuery, GQLProductHighlightQueryVariables>(
            productHighlightQuery,
            id ? { variables: { id } } : { skip: true },
        );
        

        const initialValues = useMemo<Partial<FormValues>>(() => data?.productHighlight
        ? {
            ...filterByFragment<GQLProductHighlightFormFragment>(productHighlightFormFragment, data.productHighlight),
            productCategory: data.productHighlight.product?.category
        }
        : {
            
        }
    , [data]);

        
        const saveConflict = useFormSaveConflict({
            checkConflict: async () => {
                const updatedAt = await queryUpdatedAt(client, "productHighlight", id);
                return resolveHasSaveConflict(data?.productHighlight.updatedAt, updatedAt);
            },
            formApiRef,
            loadLatestVersion: async () => {
                await refetch();
            },
        });
        

        const handleSubmit = async ({ productCategory, ...formValues }: FormValues, form: FormApi<FormValues>, event: FinalFormSubmitEvent) => {
            if (await saveConflict.checkForConflicts()) throw new Error("Conflicts detected");
            const output = {
                ...formValues,
                product: formValues.product ? formValues.product.id : null,
            };
            if (mode === "edit") {
                
                if (!id) throw new Error();
                const {  ...updateInput } = output;
                await client.mutate<GQLUpdateProductHighlightMutation, GQLUpdateProductHighlightMutationVariables>({
                    mutation: updateProductHighlightMutation,
                    variables: { id, input: updateInput },
                });
                
            } else {
                
                const { data: mutationResponse } = await client.mutate<GQLCreateProductHighlightMutation, GQLCreateProductHighlightMutationVariables>({
                    mutation: createProductHighlightMutation,
                    variables: { input: output },
                });
                if (!event.navigatingBack) {
                    const id = mutationResponse?.createProductHighlight.id;
                    if (id) {
                        setTimeout(() => {
                            stackSwitchApi.activatePage(\`edit\`, id);
                        });
                    }
                }
                
            }
        };

        

         if (error) throw error;

                    if (loading) {
                        return <Loading behavior="fillPageHeight" />;
                    }

        return (
            <FinalForm<FormValues>
                apiRef={formApiRef}
                onSubmit={handleSubmit}
                mode={mode}
                initialValues={initialValues}
                initialValuesEqual={isEqual} //required to compare block data correctly
                subscription={{ values: true }}
            >
                {({values, form}) => (
                    <>
                        {saveConflict.dialogs}
                        <>
                            <AsyncSelectField
                required
                variant="horizontal"
                fullWidth
                
                
                name="productCategory"
                label={<FormattedMessage id="productHighlight.productCategory" defaultMessage="Product Category" />}
                
                loadOptions={async () => {
                    const { data } = await client.query<GQLProductCategoriesSelectQuery, GQLProductCategoriesSelectQueryVariables>({
                        query: gql\`query ProductCategoriesSelect
                            
                            
                            
                         {
                            productCategories
                                
                                
                             {
                                nodes {
                                    id
                                    title
                                }
                            }
                        }\`
                            
                            
                        
                    });
                    return data.productCategories.nodes;
                }}
                getOptionLabel={(option) => option.title}
                
            />
<AsyncSelectField
                
                variant="horizontal"
                fullWidth
                
                
                name="product"
                label={<FormattedMessage id="productHighlight.product" defaultMessage="Product" />}
                
                loadOptions={async () => {
                    const { data } = await client.query<GQLProductsSelectQuery, GQLProductsSelectQueryVariables>({
                        query: gql\`query ProductsSelect(
                            $filter: ProductFilter
                            
                            
                        ) {
                            products(
                                filter: $filter
                                
                            ) {
                                nodes {
                                    id
                                    title
                                }
                            }
                        }\`, variables: { 
                            filter: { category: { equal: values.productCategory?.id } },
                            
                         }
                    });
                    return data.products.nodes;
                }}
                getOptionLabel={(option) => option.title}
                disabled={!values?.productCategory}
            /><OnChangeField name="productCategory">
                            {(value, previousValue) => {
                                if (value.id !== previousValue.id) {
                                    form.change("product", undefined);
                                }
                            }}
                        </OnChangeField>
                        </>
                    </>
                )}
            </FinalForm>
        );
    }

    "
`;

exports[`AsyncSelectFilter generates filter with value dependent on other field 1`] = `
"<AsyncSelectField
                required
                variant="horizontal"
                fullWidth
                
                
                name="category"
                label={<FormattedMessage id="product.category" defaultMessage="Category" />}
                
                loadOptions={async () => {
                    const { data } = await client.query<GQLCategoriesSelectQuery, GQLCategoriesSelectQueryVariables>({
                        query: gql\`query CategoriesSelect(
                            $title: String
                            
                            
                        ) {
                            categories(
                                title: $title
                                
                            ) {
                                nodes {
                                    id
                                    name
                                }
                            }
                        }\`, variables: { 
                            title: values.title,
                            
                         }
                    });
                    return data.categories.nodes;
                }}
                getOptionLabel={(option) => option.name}
                disabled={!values?.title}
            /><OnChangeField name="title">
                            {(value, previousValue) => {
                                if (value.id !== previousValue.id) {
                                    form.change("category", undefined);
                                }
                            }}
                        </OnChangeField>"
`;

exports[`AsyncSelectFilter generates formProp with enum filter as root query arg 1`] = `
"
    import { FormattedMessage } from "react-intl";
import { useApolloClient } from "@apollo/client";
import { useQuery } from "@apollo/client";
import { gql } from "@apollo/client";
import { CheckboxField } from "@comet/admin";
import { Field } from "@comet/admin";
import { filterByFragment } from "@comet/admin";
import { FinalForm } from "@comet/admin";
import { FinalFormInput } from "@comet/admin";
import { FinalFormRangeInput } from "@comet/admin";
import { FinalFormSelect } from "@comet/admin";
import { FinalFormSubmitEvent } from "@comet/admin";
import { Loading } from "@comet/admin";
import { NumberField } from "@comet/admin";
import { RadioGroupField } from "@comet/admin";
import { TextAreaField } from "@comet/admin";
import { TextField } from "@comet/admin";
import { useFormApiRef } from "@comet/admin";
import { useStackSwitchApi } from "@comet/admin";
import { ArrowLeft } from "@comet/admin-icons";
import { Lock } from "@comet/admin-icons";
import { DateTimeField } from "@comet/admin-date-time";
import { FinalFormDatePicker } from "@comet/admin-date-time";
import { BlockState } from "@comet/cms-admin";
import { createFinalFormBlock } from "@comet/cms-admin";
import { queryUpdatedAt } from "@comet/cms-admin";
import { resolveHasSaveConflict } from "@comet/cms-admin";
import { useFormSaveConflict } from "@comet/cms-admin";
import { FileUploadField } from "@comet/cms-admin";
import { IconButton } from "@mui/material";
import { MenuItem } from "@mui/material";
import { InputAdornment } from "@mui/material";
import { FormApi } from "final-form";
import { useMemo } from "react";
import { GQLCategoryType } from "@src/graphql.generated";
import { OnChangeField } from "@comet/admin";
import { GQLCategoriesSelectQuery } from "./ProductForm.generated";
import { GQLCategoriesSelectQueryVariables } from "./ProductForm.generated";
import { AsyncSelectField } from "@comet/admin";
import { productFormFragment } from "./ProductForm.gql";
import { GQLProductFormFragment } from "./ProductForm.gql.generated";
import { productQuery } from "./ProductForm.gql";
import { GQLProductQuery } from "./ProductForm.gql.generated";
import { GQLProductQueryVariables } from "./ProductForm.gql.generated";
import { createProductMutation } from "./ProductForm.gql";
import { GQLCreateProductMutation } from "./ProductForm.gql.generated";
import { GQLCreateProductMutationVariables } from "./ProductForm.gql.generated";
import { updateProductMutation } from "./ProductForm.gql";
import { GQLUpdateProductMutation } from "./ProductForm.gql.generated";
import { GQLUpdateProductMutationVariables } from "./ProductForm.gql.generated";
    import isEqual from "lodash.isequal";

    

    

    type FormValues = GQLProductFormFragment ;

    interface FormProps {
            type: GQLCategoryType;
id?: string;
        }

    export function ProductForm({type, id}: FormProps) {
        const client = useApolloClient();
        const mode = id ? "edit" : "add";
        const formApiRef = useFormApiRef<FormValues>();
        const stackSwitchApi = useStackSwitchApi();

        
        const { data, error, loading, refetch } = useQuery<GQLProductQuery, GQLProductQueryVariables>(
            productQuery,
            id ? { variables: { id } } : { skip: true },
        );
        

        const initialValues = useMemo<Partial<FormValues>>(() => data?.product
        ? {
            ...filterByFragment<GQLProductFormFragment>(productFormFragment, data.product),
            
        }
        : {
            
        }
    , [data]);

        
        const saveConflict = useFormSaveConflict({
            checkConflict: async () => {
                const updatedAt = await queryUpdatedAt(client, "product", id);
                return resolveHasSaveConflict(data?.product.updatedAt, updatedAt);
            },
            formApiRef,
            loadLatestVersion: async () => {
                await refetch();
            },
        });
        

        const handleSubmit = async (formValues: FormValues, form: FormApi<FormValues>, event: FinalFormSubmitEvent) => {
            if (await saveConflict.checkForConflicts()) throw new Error("Conflicts detected");
            const output = {
                ...formValues,
                category: formValues.category?.id,
            };
            if (mode === "edit") {
                
                if (!id) throw new Error();
                const {  ...updateInput } = output;
                await client.mutate<GQLUpdateProductMutation, GQLUpdateProductMutationVariables>({
                    mutation: updateProductMutation,
                    variables: { id, input: updateInput },
                });
                
            } else {
                
                const { data: mutationResponse } = await client.mutate<GQLCreateProductMutation, GQLCreateProductMutationVariables>({
                    mutation: createProductMutation,
                    variables: { input: output },
                });
                if (!event.navigatingBack) {
                    const id = mutationResponse?.createProduct.id;
                    if (id) {
                        setTimeout(() => {
                            stackSwitchApi.activatePage(\`edit\`, id);
                        });
                    }
                }
                
            }
        };

        

         if (error) throw error;

                    if (loading) {
                        return <Loading behavior="fillPageHeight" />;
                    }

        return (
            <FinalForm<FormValues>
                apiRef={formApiRef}
                onSubmit={handleSubmit}
                mode={mode}
                initialValues={initialValues}
                initialValuesEqual={isEqual} //required to compare block data correctly
                subscription={{ values: true }}
            >
                {({values, form}) => (
                    <>
                        {saveConflict.dialogs}
                        <>
                            <AsyncSelectField
                required
                variant="horizontal"
                fullWidth
                
                
                name="category"
                label={<FormattedMessage id="product.category" defaultMessage="Category" />}
                
                loadOptions={async () => {
                    const { data } = await client.query<GQLCategoriesSelectQuery, GQLCategoriesSelectQueryVariables>({
                        query: gql\`query CategoriesSelect(
                            $type: CategoryType
                            
                            
                        ) {
                            categories(
                                type: $type
                                
                            ) {
                                nodes {
                                    id
                                    name
                                }
                            }
                        }\`, variables: { 
                            type: type,
                            
                         }
                    });
                    return data.categories.nodes;
                }}
                getOptionLabel={(option) => option.name}
                
            />
                        </>
                    </>
                )}
            </FinalForm>
        );
    }

    "
`;

exports[`AsyncSelectFilter with formProp filter with filter arg generates a string filter 1`] = `
"
    import { FormattedMessage } from "react-intl";
import { useApolloClient } from "@apollo/client";
import { useQuery } from "@apollo/client";
import { gql } from "@apollo/client";
import { CheckboxField } from "@comet/admin";
import { Field } from "@comet/admin";
import { filterByFragment } from "@comet/admin";
import { FinalForm } from "@comet/admin";
import { FinalFormInput } from "@comet/admin";
import { FinalFormRangeInput } from "@comet/admin";
import { FinalFormSelect } from "@comet/admin";
import { FinalFormSubmitEvent } from "@comet/admin";
import { Loading } from "@comet/admin";
import { NumberField } from "@comet/admin";
import { RadioGroupField } from "@comet/admin";
import { TextAreaField } from "@comet/admin";
import { TextField } from "@comet/admin";
import { useFormApiRef } from "@comet/admin";
import { useStackSwitchApi } from "@comet/admin";
import { ArrowLeft } from "@comet/admin-icons";
import { Lock } from "@comet/admin-icons";
import { DateTimeField } from "@comet/admin-date-time";
import { FinalFormDatePicker } from "@comet/admin-date-time";
import { BlockState } from "@comet/cms-admin";
import { createFinalFormBlock } from "@comet/cms-admin";
import { queryUpdatedAt } from "@comet/cms-admin";
import { resolveHasSaveConflict } from "@comet/cms-admin";
import { useFormSaveConflict } from "@comet/cms-admin";
import { FileUploadField } from "@comet/cms-admin";
import { IconButton } from "@mui/material";
import { MenuItem } from "@mui/material";
import { InputAdornment } from "@mui/material";
import { FormApi } from "final-form";
import { useMemo } from "react";
import { OnChangeField } from "@comet/admin";
import { GQLCategoriesSelectQuery } from "./ProductForm.generated";
import { GQLCategoriesSelectQueryVariables } from "./ProductForm.generated";
import { AsyncSelectField } from "@comet/admin";
import { productFormFragment } from "./ProductForm.gql";
import { GQLProductFormFragment } from "./ProductForm.gql.generated";
import { productQuery } from "./ProductForm.gql";
import { GQLProductQuery } from "./ProductForm.gql.generated";
import { GQLProductQueryVariables } from "./ProductForm.gql.generated";
import { createProductMutation } from "./ProductForm.gql";
import { GQLCreateProductMutation } from "./ProductForm.gql.generated";
import { GQLCreateProductMutationVariables } from "./ProductForm.gql.generated";
import { updateProductMutation } from "./ProductForm.gql";
import { GQLUpdateProductMutation } from "./ProductForm.gql.generated";
import { GQLUpdateProductMutationVariables } from "./ProductForm.gql.generated";
    import isEqual from "lodash.isequal";

    

    

    type FormValues = GQLProductFormFragment ;

    interface FormProps {
            foo: string;
id?: string;
        }

    export function ProductForm({foo, id}: FormProps) {
        const client = useApolloClient();
        const mode = id ? "edit" : "add";
        const formApiRef = useFormApiRef<FormValues>();
        const stackSwitchApi = useStackSwitchApi();

        
        const { data, error, loading, refetch } = useQuery<GQLProductQuery, GQLProductQueryVariables>(
            productQuery,
            id ? { variables: { id } } : { skip: true },
        );
        

        const initialValues = useMemo<Partial<FormValues>>(() => data?.product
        ? {
            ...filterByFragment<GQLProductFormFragment>(productFormFragment, data.product),
            
        }
        : {
            
        }
    , [data]);

        
        const saveConflict = useFormSaveConflict({
            checkConflict: async () => {
                const updatedAt = await queryUpdatedAt(client, "product", id);
                return resolveHasSaveConflict(data?.product.updatedAt, updatedAt);
            },
            formApiRef,
            loadLatestVersion: async () => {
                await refetch();
            },
        });
        

        const handleSubmit = async (formValues: FormValues, form: FormApi<FormValues>, event: FinalFormSubmitEvent) => {
            if (await saveConflict.checkForConflicts()) throw new Error("Conflicts detected");
            const output = {
                ...formValues,
                category: formValues.category?.id,
            };
            if (mode === "edit") {
                
                if (!id) throw new Error();
                const {  ...updateInput } = output;
                await client.mutate<GQLUpdateProductMutation, GQLUpdateProductMutationVariables>({
                    mutation: updateProductMutation,
                    variables: { id, input: updateInput },
                });
                
            } else {
                
                const { data: mutationResponse } = await client.mutate<GQLCreateProductMutation, GQLCreateProductMutationVariables>({
                    mutation: createProductMutation,
                    variables: { input: output },
                });
                if (!event.navigatingBack) {
                    const id = mutationResponse?.createProduct.id;
                    if (id) {
                        setTimeout(() => {
                            stackSwitchApi.activatePage(\`edit\`, id);
                        });
                    }
                }
                
            }
        };

        

         if (error) throw error;

                    if (loading) {
                        return <Loading behavior="fillPageHeight" />;
                    }

        return (
            <FinalForm<FormValues>
                apiRef={formApiRef}
                onSubmit={handleSubmit}
                mode={mode}
                initialValues={initialValues}
                initialValuesEqual={isEqual} //required to compare block data correctly
                subscription={{ values: true }}
            >
                {({values, form}) => (
                    <>
                        {saveConflict.dialogs}
                        <>
                            <AsyncSelectField
                required
                variant="horizontal"
                fullWidth
                
                
                name="category"
                label={<FormattedMessage id="product.category" defaultMessage="Category" />}
                
                loadOptions={async () => {
                    const { data } = await client.query<GQLCategoriesSelectQuery, GQLCategoriesSelectQueryVariables>({
                        query: gql\`query CategoriesSelect(
                            $filter: CategoryFilter
                            
                            
                        ) {
                            categories(
                                filter: $filter
                                
                            ) {
                                nodes {
                                    id
                                    name
                                }
                            }
                        }\`, variables: { 
                            filter: { foo: { equal: foo } },
                            
                         }
                    });
                    return data.categories.nodes;
                }}
                getOptionLabel={(option) => option.name}
                
            />
                        </>
                    </>
                )}
            </FinalForm>
        );
    }

    "
`;

exports[`AsyncSelectFilter with formProp filter with filter arg generates an enum filter 1`] = `
"
    import { FormattedMessage } from "react-intl";
import { useApolloClient } from "@apollo/client";
import { useQuery } from "@apollo/client";
import { gql } from "@apollo/client";
import { CheckboxField } from "@comet/admin";
import { Field } from "@comet/admin";
import { filterByFragment } from "@comet/admin";
import { FinalForm } from "@comet/admin";
import { FinalFormInput } from "@comet/admin";
import { FinalFormRangeInput } from "@comet/admin";
import { FinalFormSelect } from "@comet/admin";
import { FinalFormSubmitEvent } from "@comet/admin";
import { Loading } from "@comet/admin";
import { NumberField } from "@comet/admin";
import { RadioGroupField } from "@comet/admin";
import { TextAreaField } from "@comet/admin";
import { TextField } from "@comet/admin";
import { useFormApiRef } from "@comet/admin";
import { useStackSwitchApi } from "@comet/admin";
import { ArrowLeft } from "@comet/admin-icons";
import { Lock } from "@comet/admin-icons";
import { DateTimeField } from "@comet/admin-date-time";
import { FinalFormDatePicker } from "@comet/admin-date-time";
import { BlockState } from "@comet/cms-admin";
import { createFinalFormBlock } from "@comet/cms-admin";
import { queryUpdatedAt } from "@comet/cms-admin";
import { resolveHasSaveConflict } from "@comet/cms-admin";
import { useFormSaveConflict } from "@comet/cms-admin";
import { FileUploadField } from "@comet/cms-admin";
import { IconButton } from "@mui/material";
import { MenuItem } from "@mui/material";
import { InputAdornment } from "@mui/material";
import { FormApi } from "final-form";
import { useMemo } from "react";
import { GQLCategoryType } from "@src/graphql.generated";
import { OnChangeField } from "@comet/admin";
import { GQLCategoriesSelectQuery } from "./ProductForm.generated";
import { GQLCategoriesSelectQueryVariables } from "./ProductForm.generated";
import { AsyncSelectField } from "@comet/admin";
import { productFormFragment } from "./ProductForm.gql";
import { GQLProductFormFragment } from "./ProductForm.gql.generated";
import { productQuery } from "./ProductForm.gql";
import { GQLProductQuery } from "./ProductForm.gql.generated";
import { GQLProductQueryVariables } from "./ProductForm.gql.generated";
import { createProductMutation } from "./ProductForm.gql";
import { GQLCreateProductMutation } from "./ProductForm.gql.generated";
import { GQLCreateProductMutationVariables } from "./ProductForm.gql.generated";
import { updateProductMutation } from "./ProductForm.gql";
import { GQLUpdateProductMutation } from "./ProductForm.gql.generated";
import { GQLUpdateProductMutationVariables } from "./ProductForm.gql.generated";
    import isEqual from "lodash.isequal";

    

    

    type FormValues = GQLProductFormFragment ;

    interface FormProps {
            categoryType: GQLCategoryType;
id?: string;
        }

    export function ProductForm({categoryType, id}: FormProps) {
        const client = useApolloClient();
        const mode = id ? "edit" : "add";
        const formApiRef = useFormApiRef<FormValues>();
        const stackSwitchApi = useStackSwitchApi();

        
        const { data, error, loading, refetch } = useQuery<GQLProductQuery, GQLProductQueryVariables>(
            productQuery,
            id ? { variables: { id } } : { skip: true },
        );
        

        const initialValues = useMemo<Partial<FormValues>>(() => data?.product
        ? {
            ...filterByFragment<GQLProductFormFragment>(productFormFragment, data.product),
            
        }
        : {
            
        }
    , [data]);

        
        const saveConflict = useFormSaveConflict({
            checkConflict: async () => {
                const updatedAt = await queryUpdatedAt(client, "product", id);
                return resolveHasSaveConflict(data?.product.updatedAt, updatedAt);
            },
            formApiRef,
            loadLatestVersion: async () => {
                await refetch();
            },
        });
        

        const handleSubmit = async (formValues: FormValues, form: FormApi<FormValues>, event: FinalFormSubmitEvent) => {
            if (await saveConflict.checkForConflicts()) throw new Error("Conflicts detected");
            const output = {
                ...formValues,
                category: formValues.category?.id,
            };
            if (mode === "edit") {
                
                if (!id) throw new Error();
                const {  ...updateInput } = output;
                await client.mutate<GQLUpdateProductMutation, GQLUpdateProductMutationVariables>({
                    mutation: updateProductMutation,
                    variables: { id, input: updateInput },
                });
                
            } else {
                
                const { data: mutationResponse } = await client.mutate<GQLCreateProductMutation, GQLCreateProductMutationVariables>({
                    mutation: createProductMutation,
                    variables: { input: output },
                });
                if (!event.navigatingBack) {
                    const id = mutationResponse?.createProduct.id;
                    if (id) {
                        setTimeout(() => {
                            stackSwitchApi.activatePage(\`edit\`, id);
                        });
                    }
                }
                
            }
        };

        

         if (error) throw error;

                    if (loading) {
                        return <Loading behavior="fillPageHeight" />;
                    }

        return (
            <FinalForm<FormValues>
                apiRef={formApiRef}
                onSubmit={handleSubmit}
                mode={mode}
                initialValues={initialValues}
                initialValuesEqual={isEqual} //required to compare block data correctly
                subscription={{ values: true }}
            >
                {({values, form}) => (
                    <>
                        {saveConflict.dialogs}
                        <>
                            <AsyncSelectField
                required
                variant="horizontal"
                fullWidth
                
                
                name="category"
                label={<FormattedMessage id="product.category" defaultMessage="Category" />}
                
                loadOptions={async () => {
                    const { data } = await client.query<GQLCategoriesSelectQuery, GQLCategoriesSelectQueryVariables>({
                        query: gql\`query CategoriesSelect(
                            $filter: CategoryFilter
                            
                            
                        ) {
                            categories(
                                filter: $filter
                                
                            ) {
                                nodes {
                                    id
                                    name
                                }
                            }
                        }\`, variables: { 
                            filter: { type: { equal: categoryType } },
                            
                         }
                    });
                    return data.categories.nodes;
                }}
                getOptionLabel={(option) => option.name}
                
            />
                        </>
                    </>
                )}
            </FinalForm>
        );
    }

    "
`;
