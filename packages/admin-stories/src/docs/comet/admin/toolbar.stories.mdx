import { Meta, Story, Canvas } from "@storybook/addon-docs/blocks";
import {
    Toolbar,
    ToolbarItem,
    ToolbarBackButton,
    Field,
    ToolbarFillSpace,
    FinalFormInput,
    ToolbarActions,
    ToolbarAutomaticTitleItem,
    StackSwitchApiContext,
    StackApiContext,
    FinalFormSearchTextField,
    ToolbarBreadcrumbs,
    SplitButton,
    SaveButton,
    ToolbarTitleItem,
} from "@comet/admin";
import { Button, IconButton, Typography, Grid, TextField, InputAdornment } from "@material-ui/core";
import { toolbarDecorator } from "./toolbar.decorator";
import { ChevronLeft, CometColor, Search } from "@comet/admin-icons";

import StoryRouter from "storybook-react-router";
import { FormattedMessage } from "react-intl";
import { Autocomplete } from "@material-ui/lab";
import { Form, FormProps, FormRenderProps } from "react-final-form";

<Meta title="docs/@comet/admin/toolbar" decorators={[toolbarDecorator(), StoryRouter()]} />

# Toolbar

The Toolbar System is a lightweight drop-in system to build a common and recognizable UI Pattern over all `@comet/admin` screens. It offers a structured place for Back Button, Title, Breadcrumbs, Action Buttons, Filters, Filter Bar, and many other UI Components which concern the current presented screen.

## Components

The Toolbar system currently exists of some basic components. Everything is designed to offer the developer a structured, easy usable, customizable and extendable toolbar system. From the User perspective the `@comet/admin` Toolbar should offer an application wide consistent UI, where the user consistently knows where one can find the back button, breadcrumbs, screen title or call to action buttons.

Current supported and built in components:

-   `Toolbar`
-   `ToolbarBackButton`
-   `ToolbarBreadcrumbs`
-   `ToolbarAutomaticTitleItem`
-   `ToolbarFillSpace`
-   `ToolbarItem`
-   `ToolbarActions`

### Toolbar

An empty Toolbar is nothing really fency and not even more than a Mui Paper/ Mui Toolbar which sticks on the right place. Do not use empty toolbars at all, that makes really no sense. Try to always put a title, back button or at some rare cases breadcrumbs into it. Even on an entry screen with just a table, it is recommended to add a toolbar with a title. If the user moves to a detail screen, the toolbar sticks at the same place and changes the content according to the needs of the new screen.

<Canvas>
    <Story name="Toolbar - Empty">
        <Toolbar />
    </Story>
</Canvas>

### ToolbarAutomaticTitleItem

The `ToolbarAutomaticTitleItem` uses the StackApi to evaluate the title. Just drop it in the toolbar and the title will be fetched automatically.

If you need a custom title, simple build your own `CustomToolbarTitleItem`. For custom appearance - see more on custom title stories.

<Canvas>
    <Story name="ToolbarAutomaticTitleItem">
        <Toolbar>
            <ToolbarAutomaticTitleItem />
        </Toolbar>
    </Story>
</Canvas>

### ToolbarTitleItem

If you only want a consistent Title over the all application, we recommend to use our ToolbarTitleItem. Simple put your Component in it, and if it is a string, it will get a consistent styling over the whole application

<Canvas>
    <Story name="ToolbarTitleItem">
        <Toolbar>
            <ToolbarTitleItem>Toolbar Title Item</ToolbarTitleItem>
        </Toolbar>
    </Story>
</Canvas>

### ToolbarTitleItem internationalization

<Canvas>
    <Story name="Localized Title">
        <Toolbar>
            <ToolbarTitleItem>
                <FormattedMessage id={"storybook.toolbartitleitem.title"} defaultMessage={"Localized Title"} />
            </ToolbarTitleItem>
        </Toolbar>
    </Story>
</Canvas>

### ToolbarBreadcrumbs

The ToolbarBreadcrumbs Component used the StackApi to evaluate all necessary Breadcrumbs to display.

Breadcrumb entries get displayed side by side and are clickable.

<Canvas>
    <Story name="Toolbar - Breadcrumbs">
        <Toolbar>
            <ToolbarBackButton />
            <ToolbarBreadcrumbs />
            <ToolbarFillSpace />
            <ToolbarActions>
                <StackSwitchApiContext.Consumer>
                    {(stackSwitchApi) => (
                        <Grid container spacing={4}>
                            <Grid item>
                                <Button
                                    color={"primary"}
                                    variant={"contained"}
                                    onClick={() => {
                                        stackSwitchApi.activatePage("page-1", "details");
                                    }}
                                >
                                    1
                                </Button>
                            </Grid>
                            <Grid item>
                                <Button
                                    color={"primary"}
                                    variant={"contained"}
                                    onClick={() => {
                                        stackSwitchApi.activatePage("page-2", "details");
                                    }}
                                >
                                    2
                                </Button>
                            </Grid>
                        </Grid>
                    )}
                </StackSwitchApiContext.Consumer>
            </ToolbarActions>
        </Toolbar>
    </Story>
</Canvas>

### ToolbarBackButton

The `ToolbarBackButton` uses the `StackApiContext` to evaluate, if the user can go back. It should offer a simple and common drop in component, which indicates the user that one is inside a stack and has the possibility to go back.

The back button will only be shown, if there is a `StackApiContext` and the user can go back. If you want to use a custom back button - see more how to customize the back button on custom back button story.

<Canvas>
    <Story name="Toolbar - Back Button">
        <Toolbar>
            <ToolbarBackButton />
            <ToolbarAutomaticTitleItem />
            <ToolbarFillSpace />
            <ToolbarActions>
                <StackSwitchApiContext.Consumer>
                    {(stackSwitchApi) => (
                        <>
                            <Button
                                variant={"contained"}
                                color={"primary"}
                                onClick={() => {
                                    stackSwitchApi?.activatePage("automaticTitleDetail", "details");
                                }}
                            >
                                <Typography>Go To Details</Typography>
                            </Button>
                        </>
                    )}
                </StackSwitchApiContext.Consumer>
            </ToolbarActions>
        </Toolbar>
    </Story>
</Canvas>

### ToolbarFillSpace

The `ToolbarFillSpace` Component is a layout component that can fill space between components, so one can simple move e.g. the buttons to the right side or center them.

Here are some examples how one can use this component.

<Canvas>
    <Story name="Fill Space - left">
        <Toolbar>
            <ToolbarFillSpace />
            <ToolbarItem>
                <Typography>Item</Typography>
            </ToolbarItem>
        </Toolbar>
    </Story>
</Canvas>

<Canvas>
    <Story name="Fill Space - left and right">
        <Toolbar>
            <ToolbarFillSpace />
            <ToolbarItem>
                <Typography>Item</Typography>
            </ToolbarItem>
            <ToolbarFillSpace />
        </Toolbar>
    </Story>
</Canvas>

<Canvas>
    <Story name="Fill Space - middle">
        <Toolbar>
            <ToolbarItem>
                <Typography>Item</Typography>
            </ToolbarItem>
            <ToolbarFillSpace />
            <ToolbarItem>
                <Typography>Item</Typography>
            </ToolbarItem>
        </Toolbar>
    </Story>
</Canvas>

<Canvas>
    <Story name="Fill Space - middle 2">
        <Toolbar>
            <ToolbarItem>
                <Typography>Item</Typography>
            </ToolbarItem>
            <ToolbarFillSpace />
            <ToolbarActions>
                <Grid container spacing={4}>
                    <Grid item>
                        <Button
                            color={"primary"}
                            variant={"contained"}
                            onClick={() => {
                                alert("clicked Action 1");
                            }}
                        >
                            Action 1
                        </Button>
                    </Grid>
                    <Grid item>
                        <Button
                            color={"secondary"}
                            variant={"contained"}
                            onClick={() => {
                                alert("clicked Action 2");
                            }}
                        >
                            Action 2
                        </Button>
                    </Grid>
                </Grid>
            </ToolbarActions>
            <ToolbarFillSpace />
            <ToolbarItem>
                <Typography>Item</Typography>
            </ToolbarItem>
        </Toolbar>
    </Story>
</Canvas>

### ToolbarItem

This component is meant to separate components in the toolbar, it adds a consistent separator on the right side.

<Canvas>
    <Story name="ToolbarItem">
        <Toolbar>
            <ToolbarItem>
                <Typography>Item 1</Typography>
            </ToolbarItem>
            <ToolbarItem>
                <Typography>Item 2</Typography>
            </ToolbarItem>
            <ToolbarItem>
                <Typography>Item 3</Typography>
            </ToolbarItem>
        </Toolbar>
    </Story>
</Canvas>

The `ToolbarItem` can be easily mixed up with other drop in compoents like `ToolbarAutomaticTitleItem`

<Canvas>
    <Story name="ToolbarItem - mixing with other Components">
        <Toolbar>
            <ToolbarItem>
                <Typography>Item 1</Typography>
            </ToolbarItem>
            <ToolbarAutomaticTitleItem />
            <ToolbarItem>
                <Typography>Item 2</Typography>
            </ToolbarItem>
            <ToolbarItem>
                <Typography>Item 3</Typography>
            </ToolbarItem>
        </Toolbar>
    </Story>
</Canvas>

### ToolbarActions

<Canvas>
    <Story name="Toolbar Actions - one Action">
        <Toolbar>
            <ToolbarAutomaticTitleItem />
            <ToolbarFillSpace />
            <ToolbarActions>
                <Button
                    color={"primary"}
                    variant={"contained"}
                    onClick={() => {
                        alert("clicked Action");
                    }}
                >
                    Action
                </Button>
            </ToolbarActions>
        </Toolbar>
    </Story>
</Canvas>

<Canvas>
    <Story name="Toolbar Actions - multiple Actions">
        <Toolbar>
            <ToolbarAutomaticTitleItem />
            <ToolbarFillSpace />
            <ToolbarActions>
                <Grid container spacing={4}>
                    <Grid item>
                        <Button
                            color={"primary"}
                            variant={"contained"}
                            onClick={() => {
                                alert("clicked Action 1");
                            }}
                        >
                            Action 1
                        </Button>
                    </Grid>
                    <Grid item>
                        <Button
                            color={"secondary"}
                            variant={"contained"}
                            onClick={() => {
                                alert("clicked Action 2");
                            }}
                        >
                            Action 2
                        </Button>
                    </Grid>
                </Grid>
            </ToolbarActions>
        </Toolbar>
    </Story>
</Canvas>

### Custom Title Item

Here one can find some examples, how one can deal with custom titles. Add a `ToolbarItem` which encapsulates a `Typography` or maybe any other React component.

<Canvas>
    <Story name="Custom Title - H1">
        <Toolbar>
            <ToolbarItem>
                <Typography variant={"h1"}>Custom Title H1</Typography>
            </ToolbarItem>
        </Toolbar>
    </Story>
</Canvas>

<Canvas>
    <Story name="Custom Title - H2">
        <Toolbar>
            <ToolbarItem>
                <>
                    <CometColor fontSize={"large"} />
                    <Typography variant={"h2"}>Custom Title H2</Typography>
                </>
            </ToolbarItem>
        </Toolbar>
    </Story>
</Canvas>

One can also use totally custom components in it.

<Canvas>
    <Story name="Custom Title - H3">
        <Toolbar>
            <div style={{ display: "flex", backgroundColor: "black", alignItems: "center", paddingLeft: 20, paddingRight: 20 }}>
                <Typography variant={"h3"} color={"primary"}>
                    Custom Title H3
                </Typography>
            </div>
        </Toolbar>
    </Story>
</Canvas>

The Toolbar expands automatically if it needs more space

<Canvas>
    <Story name="Custom Title - H4">
        <Toolbar>
            <ToolbarItem>
                <div style={{ display: "flex", flexDirection: "column" }}>
                    <Typography variant={"h4"}>Multi Line - Custom Title H4</Typography>
                    <Typography variant={"h4"}>Multi Line - Custom Title H4</Typography>
                    <Typography variant={"h4"}>Multi Line - Custom Title H4</Typography>
                </div>
            </ToolbarItem>
        </Toolbar>
    </Story>
</Canvas>

### Custom Back Button

<Canvas>
    <Story name="Toolbar - Custom Back Button">
        <StackApiContext.Consumer>
            {(stackApi) => (
                <Toolbar>
                    {stackApi && stackApi.breadCrumbs.length > 1 && (
                        <ToolbarItem>
                            <IconButton
                                color={"primary"}
                                onClick={() => {
                                    stackApi.goBack?.();
                                }}
                            >
                                <ChevronLeft fontSize={"large"} />
                                <Typography>Back</Typography>
                            </IconButton>
                        </ToolbarItem>
                    )}
                    <ToolbarFillSpace />
                    <ToolbarActions>
                        <StackSwitchApiContext.Consumer>
                            {(stackSwitchApi) => (
                                <>
                                    <Button
                                        variant={"contained"}
                                        color={"primary"}
                                        onClick={() => {
                                            stackSwitchApi?.activatePage("automaticTitleDetail", "details");
                                        }}
                                    >
                                        <Typography>Go To Details</Typography>
                                    </Button>
                                </>
                            )}
                        </StackSwitchApiContext.Consumer>
                    </ToolbarActions>
                </Toolbar>
            )}
        </StackApiContext.Consumer>
    </Story>
</Canvas>

### Search - Final Form Search

<Canvas>
    <Story name="Toolbar - Search - Final Form Search">
        <Form
            onSubmit={() => {
                alert("on submit");
            }}
            render={({ values }) => {
                return (
                    <form>
                        <Toolbar>
                            <ToolbarItem>
                                <Field name="query" component={FinalFormSearchTextField} />
                            </ToolbarItem>
                            <ToolbarItem>Debug Final Form Values: {JSON.stringify(values)}</ToolbarItem>
                        </Toolbar>
                    </form>
                );
            }}
        />
    </Story>
</Canvas>

<Canvas>
    <Story name="Toolbar - Search - Final Form - Custom Icon">
        <Form
            onSubmit={() => {
                alert("on submit");
            }}
            render={({ values }) => {
                return (
                    <form>
                        <Toolbar>
                            <ToolbarItem>
                                <Field
                                    name="query"
                                    type="text"
                                    component={FinalFormSearchTextField}
                                    icon={<CometColor />}
                                    placeholder={"Comet Search"}
                                />
                            </ToolbarItem>
                            <ToolbarItem>Debug Final Form Values: {JSON.stringify(values)}</ToolbarItem>
                        </Toolbar>
                    </form>
                );
            }}
        />
    </Story>
</Canvas>

### Search - Final Form Input

<Canvas>
    <Story name="Toolbar - Search - Final Form">
        <Form
            onSubmit={() => {
                alert("on submit");
            }}
            render={({ values }) => {
                return (
                    <form>
                        <Toolbar>
                            <ToolbarItem>
                                <Field name="query" type="text" component={FinalFormInput} />
                            </ToolbarItem>
                            <ToolbarItem>Debug Final Form Values: {JSON.stringify(values)}</ToolbarItem>
                        </Toolbar>
                    </form>
                );
            }}
        />
    </Story>
</Canvas>

### Search - Autocomplete

<Canvas>
    <Story name="Toolbar - Search - Autocomplete">
        <Toolbar>
            <ToolbarItem>
                <Autocomplete
                    popupIcon={null}
                    options={[
                        { name: "Jesse Schmuck" },
                        { name: "Karie Berkman" },
                        { name: "Nena Holliman" },
                        { name: "Gustavo Snay" },
                        { name: "Jaime Santerre" },
                        { name: "Eilene Villanuev" },
                        { name: "Bernetta Kam" },
                        { name: "Amiee Galley" },
                        { name: "Sergio Dement" },
                        { name: "Lily Bellini" },
                        { name: "Isidra Wolff" },
                        { name: "Rex Mikell" },
                        { name: "Stacey Minard" },
                        { name: "Nikia Julien" },
                        { name: "Delbert Worman" },
                        { name: "Essie Delsignor" },
                        { name: "Page Vieira" },
                        { name: "Tamiko Livers" },
                        { name: "Tianna Sheeler" },
                    ]}
                    getOptionLabel={(option) => option.name}
                    style={{ width: 350 }}
                    renderInput={(params) => (
                        <TextField
                            {...params}
                            variant="outlined"
                            placeholder={"Search"}
                            InputProps={{
                                ...params.InputProps,
                                startAdornment: (
                                    <InputAdornment position="start">
                                        <div style={{ padding: 5 }}>
                                            <Search />
                                        </div>
                                    </InputAdornment>
                                ),
                            }}
                        />
                    )}
                />
            </ToolbarItem>
        </Toolbar>
    </Story>
</Canvas>

### Save

<Canvas>
    <Story name="SplitButton Save">
        {() => {
            const Story = () => {
                const [saving, setSaving] = React.useState(false);
                return (
                    <Toolbar>
                        <ToolbarTitleItem>Save Split Button</ToolbarTitleItem>
                        <ToolbarFillSpace />
                        <ToolbarActions>
                            <SplitButton localStorageKey={"Page5.SaveSplitButton"} color={"primary"} variant={"contained"}>
                                <SaveButton
                                    saving={saving}
                                    onClick={() => {
                                        setSaving(true);
                                        setTimeout(() => {
                                            setSaving(false);
                                        }, 1000);
                                    }}
                                >
                                    <FormattedMessage id={"comet.save"} defaultMessage={"Save"} />
                                </SaveButton>
                                <SaveButton
                                    saving={saving}
                                    onClick={() => {
                                        setSaving(true);
                                        setTimeout(() => {
                                            setSaving(false);
                                        }, 1000);
                                    }}
                                >
                                    <FormattedMessage id={"comet.saveAndGoBack"} defaultMessage={"Save and Go Back"} />
                                </SaveButton>
                            </SplitButton>
                        </ToolbarActions>
                    </Toolbar>
                );
            };
            return <Story />;
        }}
    </Story>
</Canvas>

<Canvas>
    <Story name="Save">
        {() => {
            const Story = () => {
                const [saving, setSaving] = React.useState(false);
                return (
                    <Toolbar>
                        <ToolbarTitleItem>Save Button</ToolbarTitleItem>
                        <ToolbarFillSpace />
                        <ToolbarActions>
                            <SaveButton
                                color={"primary"}
                                variant={"contained"}
                                saving={saving}
                                onClick={() => {
                                    setSaving(true);
                                    setTimeout(() => {
                                        setSaving(false);
                                    }, 1000);
                                }}
                            >
                                <FormattedMessage id={"comet.save"} defaultMessage={"Save"} />
                            </SaveButton>
                        </ToolbarActions>
                    </Toolbar>
                );
            };
            return <Story />;
        }}
    </Story>
</Canvas>
