// This file has been generated by comet admin-generator.
    // You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
    import { useApolloClient, useQuery, gql } from "@apollo/client";
    import {
        AsyncSelectField,
        CheckboxField,
        Field,
        filterByFragment,
        FinalForm,
        FinalFormInput,
        FinalFormRangeInput,
        FinalFormSelect,
        FinalFormSubmitEvent,
        Loading,
        RadioGroupField,
        TextAreaField,
        TextField,
        useFormApiRef,
        useStackSwitchApi,
    } from "@comet/admin";
    import { ArrowLeft, Lock } from "@comet/admin-icons";
    import { DateTimeField, FinalFormDatePicker } from "@comet/admin-date-time";
    import { BlockState, createFinalFormBlock, queryUpdatedAt, resolveHasSaveConflict, useFormSaveConflict, FileUploadField } from "@comet/cms-admin";
    import { FormControlLabel, IconButton, MenuItem, InputAdornment } from "@mui/material";
    import { FormApi } from "final-form";
    import isEqual from "lodash.isequal";
    import { useMemo } from "react";
    import { FormattedMessage } from "react-intl";
    import { GQLProductType } from "@src/graphql.generated";
import { DamImageBlock } from "@comet/cms-admin";
import { FieldSet } from "@comet/admin";
import { productFormFragment } from "./StaticSelectInputTypeSelect.gql";
import { GQLStaticSelectInputTypeSelectFragment } from "./StaticSelectInputTypeSelect.gql.generated";
import { GQLStaticSelectInputTypeSelectFragmentVariables } from "./StaticSelectInputTypeSelect.gql.generated";
import { productQuery } from "./StaticSelectInputTypeSelect.gql";
import { GQLProductQuery } from "./StaticSelectInputTypeSelect.gql.generated";
import { GQLProductQueryVariables } from "./StaticSelectInputTypeSelect.gql.generated";
import { createProductMutation } from "./StaticSelectInputTypeSelect.gql";
import { GQLCreateProductMutation } from "./StaticSelectInputTypeSelect.gql.generated";
import { GQLCreateProductMutationVariables } from "./StaticSelectInputTypeSelect.gql.generated";
import { updateProductMutation } from "./StaticSelectInputTypeSelect.gql";
import { GQLUpdateProductMutation } from "./StaticSelectInputTypeSelect.gql.generated";
import { GQLUpdateProductMutationVariables } from "./StaticSelectInputTypeSelect.gql.generated";
    const rootBlocks = {
                image: DamImageBlock
                };

    

    type FormValues = GQLStaticSelectInputTypeSelectFragment & {
                image: BlockState<typeof rootBlocks.image>;
            };

    interface FormProps {
            id?: string;
type: GQLProductType;
slug: string;
title: string;
        }

    export function StaticSelectInputTypeSelect({id, type, slug, title}: FormProps) {
        const client = useApolloClient();
        const mode = id ? "edit" : "add";
        const formApiRef = useFormApiRef<FormValues>();
        const stackSwitchApi = useStackSwitchApi();

        
        const { data, error, loading, refetch } = useQuery<GQLProductQuery, GQLProductQueryVariables>(
            productQuery,
            id ? { variables: { id } } : { skip: true },
        );
        

        const initialValues = useMemo<Partial<FormValues>>(() => data?.product
        ? {
            ...filterByFragment<GQLStaticSelectInputTypeSelectFragment>(productFormFragment, data.product),
            image: rootBlocks.image.input2State(data.product.image)
        }
        : {
            image: rootBlocks.image.defaultValues()
        }
    , [data]);

        
        const saveConflict = useFormSaveConflict({
            checkConflict: async () => {
                const updatedAt = await queryUpdatedAt(client, "product", id);
                return resolveHasSaveConflict(data?.product.updatedAt, updatedAt);
            },
            formApiRef,
            loadLatestVersion: async () => {
                await refetch();
            },
        });
        

        const handleSubmit = async (formValues: FormValues, form: FormApi<FormValues>, event: FinalFormSubmitEvent) => {
            if (await saveConflict.checkForConflicts()) throw new Error("Conflicts detected");
            const output = {
                ...formValues,
                image: rootBlocks.image.state2Output(formValues.image),
            };
            if (mode === "edit") {
                
                if (!id) throw new Error();
                const {  ...updateInput } = output;
                await client.mutate<GQLUpdateProductMutation, GQLUpdateProductMutationVariables>({
                    mutation: updateProductMutation,
                    variables: { id, input: updateInput },
                });
                
            } else {
                
                const { data: mutationResponse } = await client.mutate<GQLCreateProductMutation, GQLCreateProductMutationVariables>({
                    mutation: createProductMutation,
                    variables: { input: { ...output, title,slug,type } },
                });
                if (!event.navigatingBack) {
                    const id = mutationResponse?.createProduct.id;
                    if (id) {
                        setTimeout(() => {
                            stackSwitchApi.activatePage(`edit`, id);
                        });
                    }
                }
                
            }
        };

        

         if (error) throw error;

                    if (loading) {
                        return <Loading behavior="fillPageHeight" />;
                    }

        return (
            <FinalForm<FormValues>
                apiRef={formApiRef}
                onSubmit={handleSubmit}
                mode={mode}
                initialValues={initialValues}
                initialValuesEqual={isEqual} //required to compare block data correctly
                subscription={{  }}
            >
                {() => (
                    <>
                        {saveConflict.dialogs}
                        <>
                            
        <FieldSet
            collapsible
            initiallyExpanded={true}
            title={<FormattedMessage id="product.Tenant.title" defaultMessage="Tenant" />}
            
        >
            <Field name="image" isEqual={isEqual} label={<FormattedMessage id="product.image" defaultMessage="Image" />} variant="horizontal" fullWidth>
            {createFinalFormBlock(rootBlocks.image)}
        </Field>

        <TextField
            required
            
            variant="horizontal"
            fullWidth
            name="description"
            label={<FormattedMessage id="product.description" defaultMessage="Description" />}
            
            
            
            
        />
<RadioGroupField
             required
              variant="horizontal"
             fullWidth
             name="status"
             label={<FormattedMessage id="product.status" defaultMessage="Status" />}
             options={[
                  {
                                label: <FormattedMessage id="product.status.published" defaultMessage="Published" />,
                                value: "Published",
                            },{
                                label: <FormattedMessage id="product.status.unpublished" defaultMessage="Unpublished" />,
                                value: "Unpublished",
                            },{
                                label: <FormattedMessage id="product.status.deleted" defaultMessage="Deleted" />,
                                value: "Deleted",
                            }
            ]}/>
        </FieldSet>
                        </>
                    </>
                )}
            </FinalForm>
        );
    }

    