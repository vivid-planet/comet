// This file has been generated by comet admin-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { FormattedMessage } from "react-intl";
import { useApolloClient } from "@apollo/client";
import { useQuery } from "@apollo/client";
import { gql } from "@apollo/client";
import { AsyncSelectField } from "@comet/admin";
import { CheckboxField } from "@comet/admin";
import { Field } from "@comet/admin";
import { filterByFragment } from "@comet/admin";
import { FinalForm } from "@comet/admin";
import { FinalFormRangeInput } from "@comet/admin";
import { FinalFormSubmitEvent } from "@comet/admin";
import { Loading } from "@comet/admin";
import { NumberField } from "@comet/admin";
import { RadioGroupField } from "@comet/admin";
import { TextAreaField } from "@comet/admin";
import { TextField } from "@comet/admin";
import { useFormApiRef } from "@comet/admin";
import { useStackSwitchApi } from "@comet/admin";
import { Lock } from "@comet/admin-icons";
import { DateTimeField } from "@comet/admin-date-time";
import { FinalFormDatePicker } from "@comet/admin-date-time";
import { BlockState } from "@comet/cms-admin";
import { createFinalFormBlock } from "@comet/cms-admin";
import { queryUpdatedAt } from "@comet/cms-admin";
import { resolveHasSaveConflict } from "@comet/cms-admin";
import { useFormSaveConflict } from "@comet/cms-admin";
import { FileUploadField } from "@comet/cms-admin";
import { InputAdornment } from "@mui/material";
import { FormApi } from "final-form";
import { useMemo } from "react";
import { DamImageBlock } from "@comet/cms-admin";
import { GQLFinalFormFileUploadFragment } from "@comet/cms-admin";
import { GQLFinalFormFileUploadDownloadableFragment } from "@comet/cms-admin";
import { GQLProductCategoriesSelectQuery } from "./ProductForm.generated";
import { GQLProductCategoriesSelectQueryVariables } from "./ProductForm.generated";
import { FinalFormSwitch } from "@comet/admin";
import { messages } from "@comet/admin";
import { FormControlLabel } from "@mui/material";
import { FieldSet } from "@comet/admin";
import { FormSpy } from "react-final-form";
import { Location as LocationIcon } from "@comet/admin-icons";
import { OnChangeField } from "@comet/admin";
import { GQLManufacturersSelectQuery } from "./ProductForm.generated";
import { GQLManufacturersSelectQueryVariables } from "./ProductForm.generated";
import { CalendarToday as CalendarTodayIcon } from "@comet/admin-icons";
import { FutureProductNotice } from "../../helpers/FutureProductNotice";
import { productFormFragment } from "./ProductForm.gql";
import { GQLProductFormDetailsFragment } from "./ProductForm.gql.generated";
import { productQuery } from "./ProductForm.gql";
import { GQLProductQuery } from "./ProductForm.gql.generated";
import { GQLProductQueryVariables } from "./ProductForm.gql.generated";
import { createProductMutation } from "./ProductForm.gql";
import { GQLCreateProductMutation } from "./ProductForm.gql.generated";
import { GQLCreateProductMutationVariables } from "./ProductForm.gql.generated";
import { updateProductMutation } from "./ProductForm.gql";
import { GQLUpdateProductMutation } from "./ProductForm.gql.generated";
import { GQLUpdateProductMutationVariables } from "./ProductForm.gql.generated";
import isEqual from "lodash.isequal";
const rootBlocks = {
    image: DamImageBlock
};
type ProductFormDetailsFragment = Omit<GQLProductFormDetailsFragment, "priceList" | "datasheets"> & {
    priceList: GQLFinalFormFileUploadDownloadableFragment | null;
    datasheets: GQLFinalFormFileUploadFragment[];
};
type FormValues = Omit<ProductFormDetailsFragment, keyof typeof rootBlocks | "dimensions" | "lastCheckedAt"> & {
    dimensionsEnabled: boolean;
    dimensions: Omit<NonNullable<GQLProductFormDetailsFragment["dimensions"]>, "width" | "height" | "depth"> & {
        width: string;
        height: string;
        depth: string;
    };
    image: BlockState<typeof rootBlocks.image>;
    lastCheckedAt?: Date | null;
};
interface FormProps {
    id?: string;
}
export function ProductForm({ id }: FormProps) {
    const client = useApolloClient();
    const mode = id ? "edit" : "add";
    const formApiRef = useFormApiRef<FormValues>();
    const stackSwitchApi = useStackSwitchApi();
    const { data, error, loading, refetch } = useQuery<GQLProductQuery, GQLProductQueryVariables>(productQuery, id ? { variables: { id } } : { skip: true });
    const initialValues = useMemo<Partial<FormValues>>(() => data?.product
        ? {
            ...filterByFragment<ProductFormDetailsFragment>(productFormFragment, data.product),
            dimensionsEnabled: !!data.product.dimensions,
            dimensions: data.product.dimensions ? { width: String(data.product.dimensions.width), height: String(data.product.dimensions.height), depth: String(data.product.dimensions.depth) } : undefined,
            image: rootBlocks.image.input2State(data.product.image),
            lastCheckedAt: data.product.lastCheckedAt ? new Date(data.product.lastCheckedAt) : undefined
        }
        : {
            inStock: false,
            image: rootBlocks.image.defaultValues()
        }, [data]);
    const saveConflict = useFormSaveConflict({
        checkConflict: async () => {
            const updatedAt = await queryUpdatedAt(client, "product", id);
            return resolveHasSaveConflict(data?.product.updatedAt, updatedAt);
        },
        formApiRef,
        loadLatestVersion: async () => {
            await refetch();
        },
    });
    const handleSubmit = async ({ dimensionsEnabled, ...formValues }: FormValues, form: FormApi<FormValues>, event: FinalFormSubmitEvent) => {
        if (await saveConflict.checkForConflicts())
            throw new Error("Conflicts detected");
        const output = {
            ...formValues,
            description: formValues.description ?? null, category: formValues.category ? formValues.category.id : null, dimensions: dimensionsEnabled && formValues.dimensions ? { width: parseFloat(formValues.dimensions.width), height: parseFloat(formValues.dimensions.height), depth: parseFloat(formValues.dimensions.depth), } : null, manufacturer: formValues.manufacturer ? formValues.manufacturer.id : null, image: rootBlocks.image.state2Output(formValues.image), priceList: formValues.priceList ? formValues.priceList.id : null, datasheets: formValues.datasheets?.map(({ id }) => id), lastCheckedAt: formValues.lastCheckedAt ? formValues.lastCheckedAt.toISOString() : null,
        };
        if (mode === "edit") {
            if (!id)
                throw new Error();
            const { createdAt, ...updateInput } = output;
            await client.mutate<GQLUpdateProductMutation, GQLUpdateProductMutationVariables>({
                mutation: updateProductMutation,
                variables: { id, input: updateInput },
            });
        }
        else {
            const { data: mutationResponse } = await client.mutate<GQLCreateProductMutation, GQLCreateProductMutationVariables>({
                mutation: createProductMutation,
                variables: { input: output },
            });
            if (!event.navigatingBack) {
                const id = mutationResponse?.createProduct.id;
                if (id) {
                    setTimeout(() => {
                        stackSwitchApi.activatePage(`edit`, id);
                    });
                }
            }
        }
    };
    if (error)
        throw error;
    if (loading) {
        return <Loading behavior="fillPageHeight"/>;
    }
    return (<FinalForm<FormValues> apiRef={formApiRef} onSubmit={handleSubmit} mode={mode} initialValues={initialValues} initialValuesEqual={isEqual} //required to compare block data correctly
     subscription={{ values: true }}>
                {({ values, form }) => (<>
                        {saveConflict.dialogs}
                        <>
                            
        <FieldSet initiallyExpanded={true} title={<FormattedMessage id="product.mainData.title" defaultMessage="Main Data"/>} supportText={mode === "edit" && (<FormSpy subscription={{ values: true }}>{({ values }) => (<FormattedMessage id="product.mainData.supportText" defaultMessage="Product: {title}" values={{ ...values }}/>)}</FormSpy>)}>
            
        <TextField required variant="horizontal" fullWidth name="title" label={<FormattedMessage id="product.title" defaultMessage="Titel"/>} validate={(value: string) => value.length < 3 ? (<FormattedMessage id="product.validate.titleMustBe3CharsLog" defaultMessage="Title must be at least 3 characters long"/>) : undefined}/>

        <TextField required variant="horizontal" fullWidth name="slug" label={<FormattedMessage id="product.slug" defaultMessage="Slug"/>}/>

            <Field readOnly disabled endAdornment={<InputAdornment position="end"><Lock /></InputAdornment>} variant="horizontal" fullWidth name="createdAt" component={FinalFormDatePicker} label={<FormattedMessage id="product.createdAt" defaultMessage="Created"/>}/>

        <TextAreaField variant="horizontal" fullWidth name="description" label={<FormattedMessage id="product.description" defaultMessage="Description"/>}/>
        <RadioGroupField required variant="horizontal" fullWidth name="type" label={<FormattedMessage id="product.type" defaultMessage="Type"/>} options={[
                {
                    label: <FormattedMessage id="product.type.cap" defaultMessage="great Cap"/>,
                    value: "Cap",
                }, {
                    label: <FormattedMessage id="product.type.shirt" defaultMessage="Shirt"/>,
                    value: "Shirt",
                }, {
                    label: <FormattedMessage id="product.type.tie" defaultMessage="Tie"/>,
                    value: "Tie",
                }
            ]}/>
        <AsyncSelectField variant="horizontal" fullWidth name="category" label={<FormattedMessage id="product.category" defaultMessage="Category"/>} loadOptions={async () => {
                const { data } = await client.query<GQLProductCategoriesSelectQuery, GQLProductCategoriesSelectQueryVariables>({
                    query: gql`query ProductCategoriesSelect {
                            productCategories {
                                nodes {
                                    id
                                    title
                                }
                            }
                        }`
                });
                return data.productCategories.nodes;
            }} getOptionLabel={(option) => option.title}/>

            <Field variant="horizontal" fullWidth name="priceRange" component={FinalFormRangeInput} label={<FormattedMessage id="product.priceRange" defaultMessage="Price Range"/>} min={25} max={500} disableSlider startAdornment={<InputAdornment position="start">€</InputAdornment>}/>
        <Field fullWidth name="dimensionsEnabled" type="checkbox" label={<FormattedMessage id="product.dimensions.dimensionsEnabled" defaultMessage="Configure dimensions"/>}>
                    {(props) => (<FormControlLabel control={<FinalFormSwitch {...props}/>} label={props.input.checked ? <FormattedMessage {...messages.yes}/> : <FormattedMessage {...messages.no}/>}/>)}
                </Field>
                 <Field name="dimensionsEnabled" fullWidth subscription={{ value: true }}>
                    {({ input: { value } }) => value ? (<>
                                
            <NumberField required variant="horizontal" fullWidth name="dimensions.width" label={<FormattedMessage id="product.width" defaultMessage="Width"/>}/>

            <NumberField required variant="horizontal" fullWidth name="dimensions.height" label={<FormattedMessage id="product.height" defaultMessage="Height"/>}/>

            <NumberField required variant="horizontal" fullWidth name="dimensions.depth" label={<FormattedMessage id="product.depth" defaultMessage="Depth"/>}/>
                            </>) : null}
                </Field>
        </FieldSet>

        <FieldSet collapsible title={<FormattedMessage id="product.additionalData.title" defaultMessage="Additional Data"/>}>
            <AsyncSelectField variant="horizontal" fullWidth name="manufacturer" label={<FormattedMessage id="product.manufacturer" defaultMessage="Manufacturer"/>} startAdornment={<InputAdornment position="start"><LocationIcon /></InputAdornment>} loadOptions={async () => {
                const { data } = await client.query<GQLManufacturersSelectQuery, GQLManufacturersSelectQueryVariables>({
                    query: gql`query ManufacturersSelect($filter: ManufacturerFilter) {
                            manufacturers(filter: $filter) {
                                nodes {
                                    id
                                    name
                                }
                            }
                        }`, variables: { filter: { addressAsEmbeddable_country: { equal: values.type } } }
                });
                return data.manufacturers.nodes;
            }} getOptionLabel={(option) => option.name} disabled={!values?.type}/><OnChangeField name="type">
                            {(value, previousValue) => {
                if (value.id !== previousValue.id) {
                    form.change("manufacturer", undefined);
                }
            }}
                        </OnChangeField>
        <CheckboxField label={<FormattedMessage id="product.inStock" defaultMessage="In Stock"/>} name="inStock" fullWidth variant="horizontal"/>

            <Field variant="horizontal" fullWidth name="availableSince" component={FinalFormDatePicker} label={<FormattedMessage id="product.availableSince" defaultMessage="Available Since"/>} startAdornment={<InputAdornment position="start"><CalendarTodayIcon /></InputAdornment>}/>
        <FutureProductNotice />
        <Field name="image" isEqual={isEqual} label={<FormattedMessage id="product.image" defaultMessage="Image"/>} variant="horizontal" fullWidth>
            {createFinalFormBlock(rootBlocks.image)}
        </Field>
        <FileUploadField name="priceList" label={<FormattedMessage id="product.priceList" defaultMessage="Price List"/>} variant="horizontal" maxFileSize={4194304}/>
        <FileUploadField name="datasheets" label={<FormattedMessage id="product.datasheets" defaultMessage="Datasheets"/>} variant="horizontal" multiple maxFileSize={4194304}/>
        <DateTimeField variant="horizontal" fullWidth name="lastCheckedAt" label={<FormattedMessage id="product.lastCheckedAt" defaultMessage="Last checked at"/>}/>
        </FieldSet>
                        </>
                    </>)}
            </FinalForm>);
}
