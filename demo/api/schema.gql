# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type CurrentUserPermission {
  permission: String!
  contentScopes: [JSONObject!]!
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type CurrentUser {
  id: String!
  name: String!
  email: String!
  permissions: [CurrentUserPermission!]!
  permissionsForScope(scope: JSONObject!): [String!]!
}

type UserPermission {
  id: ID!
  source: UserPermissionSource!
  permission: String!
  validFrom: DateTime
  validTo: DateTime
  reason: String
  requestedBy: String
  approvedBy: String
  overrideContentScopes: Boolean!
  contentScopes: [JSONObject!]!
}

enum UserPermissionSource {
  MANUAL
  BY_RULE
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type Dependency {
  rootId: String!
  rootGraphqlObjectType: String!
  rootColumnName: String!
  jsonPath: String!
  visible: Boolean!
  targetGraphqlObjectType: String!
  targetId: String!
  name: String
  secondaryInformation: String
}

type PaginatedDependencies {
  nodes: [Dependency!]!
  totalCount: Int!
}

type ImageCropArea {
  focalPoint: FocalPoint!
  width: Float
  height: Float
  x: Float
  y: Float
}

enum FocalPoint {
  SMART
  CENTER
  NORTHWEST
  NORTHEAST
  SOUTHWEST
  SOUTHEAST
}

type DamFileImage {
  id: ID!
  width: Int!
  height: Int!
  exif: JSONObject
  dominantColor: String
  cropArea: ImageCropArea!
  url(width: Int!, height: Int!): String
}

type DamFileLicense {
  type: LicenseType
  details: String
  author: String
  durationFrom: DateTime
  durationTo: DateTime

  """The expirationDate is the durationTo + 1 day"""
  expirationDate: DateTime
  isNotValidYet: Boolean!
  expiresWithinThirtyDays: Boolean!
  hasExpired: Boolean!
  isValid: Boolean!
}

enum LicenseType {
  ROYALTY_FREE
  RIGHTS_MANAGED
}

type BuildTemplate {
  id: ID!
  name: String!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
}

type AutoBuildStatus {
  hasChangesSinceLastBuild: Boolean!
  lastCheck: DateTime
  nextCheck: DateTime!
}

type Build {
  id: ID!
  status: KubernetesJobStatus!
  name: String

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  trigger: String
  startTime: DateTime
  completionTime: DateTime
  estimatedCompletionTime: DateTime
}

enum KubernetesJobStatus {
  pending
  active
  succeeded
  failed
}

type KubernetesCronJob {
  id: ID!
  name: String!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  schedule: String!
  lastScheduledAt: DateTime
  lastJobRun: KubernetesJob
}

type KubernetesJob {
  id: ID!
  name: String!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  status: KubernetesJobStatus!
  startTime: DateTime
  completionTime: DateTime
}

type FilenameResponse {
  name: String!
  folderId: ID
  isOccupied: Boolean!
}

type User {
  id: String!
  name: String!
  email: String!
}

type PaginatedUserList {
  nodes: [User!]!
  totalCount: Int!
}

type Link implements DocumentInterface {
  id: ID!
  updatedAt: DateTime!
  content: LinkBlockData!
  createdAt: DateTime!
  pageTreeNode: PageTreeNode
}

interface DocumentInterface {
  id: ID!
  updatedAt: DateTime!
}

"""Link root block data"""
scalar LinkBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type Page implements DocumentInterface {
  id: ID!
  updatedAt: DateTime!
  content: PageContentBlockData!
  seo: SeoBlockData!
  createdAt: DateTime!
  pageTreeNode: PageTreeNode
  dependencies(offset: Int! = 0, limit: Int! = 25, filter: DependencyFilter, forceRefresh: Boolean! = false): PaginatedDependencies!
}

"""PageContent root block data"""
scalar PageContentBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""Seo root block data"""
scalar SeoBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input DependencyFilter {
  targetGraphqlObjectType: String
  targetId: String
  rootColumnName: String
}

type PageTreeNodeScope {
  domain: String!
  language: String!
}

type PageTreeNode {
  id: ID!
  parentId: String
  pos: Int!
  name: String!
  slug: String!
  visibility: PageTreeNodeVisibility!
  documentType: String!
  hideInMenu: Boolean!
  updatedAt: DateTime!
  scope: PageTreeNodeScope!
  category: PageTreeNodeCategory!
  userGroup: UserGroup!
  childNodes: [PageTreeNode!]!
  numberOfDescendants: Float!
  parentNode: PageTreeNode
  path: String!
  parentNodes: [PageTreeNode!]!
  document: PageContentUnion
  dependents(offset: Int! = 0, limit: Int! = 25, filter: DependentFilter, forceRefresh: Boolean! = false): PaginatedDependencies!
}

enum PageTreeNodeVisibility {
  Published
  Unpublished
  Archived
}

enum PageTreeNodeCategory {
  MainNavigation
  TopMenu
}

enum UserGroup {
  All
  Admin
  User
}

union PageContentUnion = Page | Link | PredefinedPage

input DependentFilter {
  rootGraphqlObjectType: String
  rootId: String
  rootColumnName: String
}

type PredefinedPage implements DocumentInterface {
  id: ID!
  updatedAt: DateTime!
  createdAt: DateTime!
  type: String
}

type DamScope {
  domain: String!
}

type DamFolder {
  id: ID!
  name: String!
  numberOfChildFolders: Int!
  numberOfFiles: Int!
  mpath: [ID!]!
  archived: Boolean!
  isInboxFromOtherScope: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  scope: DamScope!
  parent: DamFolder
  parents: [DamFolder!]!
}

type DamFile {
  id: ID!
  folder: DamFolder
  name: String!
  size: Int!
  mimetype: String!
  contentHash: String!
  title: String
  altText: String
  archived: Boolean!
  image: DamFileImage
  license: DamFileLicense
  createdAt: DateTime!
  updatedAt: DateTime!
  importSourceId: String
  importSourceType: String
  scope: DamScope!
  fileUrl: String!
  duplicates: [DamFile!]!
  damPath: String!
  dependents(offset: Int! = 0, limit: Int! = 25, filter: DependentFilter, forceRefresh: Boolean! = false): PaginatedDependencies!
}

type FooterContentScope {
  domain: String!
  language: String!
}

type Footer {
  id: ID!
  content: FooterContentBlockData!
  scope: FooterContentScope!
  createdAt: DateTime!
  updatedAt: DateTime!
  dependencies(offset: Int! = 0, limit: Int! = 25, filter: DependencyFilter, forceRefresh: Boolean! = false): PaginatedDependencies!
}

"""FooterContent root block data"""
scalar FooterContentBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type MainMenuItem {
  id: ID!
  node: PageTreeNode!
  content: RichTextBlockData
  createdAt: DateTime!
  updatedAt: DateTime!
  dependencies(offset: Int! = 0, limit: Int! = 25, filter: DependencyFilter, forceRefresh: Boolean! = false): PaginatedDependencies!
}

"""RichText root block data"""
scalar RichTextBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type MainMenu {
  items: [MainMenuItem!]!
}

type NewsComment {
  id: ID!
  comment: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type NewsContentScope {
  domain: String!
  language: String!
}

type News {
  id: ID!
  scope: NewsContentScope!
  slug: String!
  title: String!
  status: NewsStatus!
  date: DateTime!
  category: NewsCategory!
  image: DamImageBlockData!
  content: NewsContentBlockData!
  createdAt: DateTime!
  updatedAt: DateTime!
  comments: [NewsComment!]!
  dependencies(offset: Int! = 0, limit: Int! = 25, filter: DependencyFilter, forceRefresh: Boolean! = false): PaginatedDependencies!
  dependents(offset: Int! = 0, limit: Int! = 25, filter: DependentFilter, forceRefresh: Boolean! = false): PaginatedDependencies!
}

enum NewsStatus {
  Active
  Deleted
}

enum NewsCategory {
  Events
  Company
  Awards
}

"""DamImage root block data"""
scalar DamImageBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""NewsContent root block data"""
scalar NewsContentBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type PaginatedNews {
  nodes: [News!]!
  totalCount: Int!
}

type AlternativeAddress {
  street: String!
  streetNumber: Float
  zip: Float!
  country: String!
}

type Address {
  street: String!
  streetNumber: Float
  zip: Float!
  country: String!
  alternativeAddress: AlternativeAddress
}

type AlternativeAddressAsEmbeddable {
  street: String!
  streetNumber: Float
  zip: Float!
  country: String!
}

type AddressAsEmbeddable {
  street: String!
  streetNumber: Float
  zip: Float!
  country: String!
  alternativeAddress: AlternativeAddressAsEmbeddable!
}

type Manufacturer {
  id: ID!
  name: String!
  address: Address
  addressAsEmbeddable: AddressAsEmbeddable!
  updatedAt: DateTime!
}

type ManufacturerCountry {
  id: String!
  used: Float!
}

type PaginatedManufacturers {
  nodes: [Manufacturer!]!
  totalCount: Int!
}

type PaginatedManufacturerCountries {
  nodes: [ManufacturerCountry!]!
  totalCount: Int!
}

type ProductCategory {
  id: ID!
  title: String!
  slug: String!
  position: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  products: [Product!]!
}

type ProductColor implements DocumentInterface {
  id: ID!
  updatedAt: DateTime!
  name: String!
  hexCode: String!
  createdAt: DateTime!
}

type ProductStatistics {
  id: ID!
  views: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductToTag {
  id: String!
  exampleStatus: Boolean!
  product: Product!
  tag: ProductTag!
}

type ProductTag {
  id: ID!
  title: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  productsWithStatus: [ProductToTag!]!
  products: [Product!]!
}

type ProductVariant {
  id: ID!
  name: String!
  image: DamImageBlockData!
  createdAt: DateTime!
  updatedAt: DateTime!
  product: Product!
}

type ProductDiscounts {
  quantity: Float!
  price: Float!
}

type ProductDimensions {
  width: Float!
  height: Float!
  depth: Float!
}

type Product {
  id: ID!
  title: String!
  status: ProductStatus!
  slug: String!
  description: String!
  type: ProductType!
  additionalTypes: [ProductType!]!
  price: Float
  inStock: Boolean!
  soldCount: Int
  availableSince: DateTime
  image: DamImageBlockData!
  discounts: [ProductDiscounts!]!
  articleNumbers: [String!]!
  dimensions: ProductDimensions
  statistics: ProductStatistics
  createdAt: DateTime!
  updatedAt: DateTime!
  category: ProductCategory
  manufacturer: Manufacturer
  colors: [ProductColor!]!
  variants: [ProductVariant!]!
  tagsWithStatus: [ProductToTag!]!
  tags: [ProductTag!]!
}

enum ProductStatus {
  Published
  Unpublished
  Deleted
}

enum ProductType {
  Cap
  Shirt
  Tie
}

type PaginatedProducts {
  nodes: [Product!]!
  totalCount: Int!
}

type PaginatedProductCategories {
  nodes: [ProductCategory!]!
  totalCount: Int!
}

type PaginatedProductTags {
  nodes: [ProductTag!]!
  totalCount: Int!
}

type PaginatedProductVariants {
  nodes: [ProductVariant!]!
  totalCount: Int!
}

type RedirectScope {
  domain: String!
}

type PaginatedPageTreeNodes {
  nodes: [PageTreeNode!]!
  totalCount: Int!
}

type Redirect {
  id: ID!
  sourceType: RedirectSourceTypeValues!
  source: String!
  target: JSONObject!
  comment: String
  active: Boolean!
  generationType: RedirectGenerationType!
  createdAt: DateTime!
  updatedAt: DateTime!
  scope: RedirectScope!
  dependencies(offset: Int! = 0, limit: Int! = 25, filter: DependencyFilter, forceRefresh: Boolean! = false): PaginatedDependencies!
}

enum RedirectSourceTypeValues {
  path
}

enum RedirectGenerationType {
  manual
  automatic
}

type PaginatedRedirects {
  nodes: [Redirect!]!
  totalCount: Int!
}

type PaginatedDamItems {
  nodes: [DamItem!]!
  totalCount: Int!
}

union DamItem = DamFile | DamFolder

type CopyFilesResponse {
  mappedFiles: [MappedFile!]!
}

type MappedFile {
  rootFile: DamFile!
  copy: DamFile!
}

type PaginatedDamFiles {
  nodes: [DamFile!]!
  totalCount: Int!
}

type PaginatedDamFolders {
  nodes: [DamFolder!]!
  totalCount: Int!
}

input PageTreeNodeScopeInput {
  domain: String!
  language: String!
}

input DamScopeInput {
  domain: String!
}

input FooterContentScopeInput {
  domain: String!
  language: String!
}

input NewsContentScopeInput {
  domain: String!
  language: String!
}

input AlternativeAddressInput {
  street: String!
  streetNumber: Float
  zip: Float!
  country: String!
}

input AddressInput {
  street: String!
  streetNumber: Float
  zip: Float!
  country: String!
  alternativeAddress: AlternativeAddressInput
}

input AlternativeAddressAsEmbeddableInput {
  street: String!
  streetNumber: Float
  zip: Float!
  country: String!
}

input AddressAsEmbeddableInput {
  street: String!
  streetNumber: Float
  zip: Float!
  country: String!
  alternativeAddress: AlternativeAddressAsEmbeddableInput!
}

input ProductDiscountsInput {
  quantity: Float!
  price: Float!
}

input ProductDimensionsInput {
  width: Float!
  height: Float!
  depth: Float!
}

input RedirectScopeInput {
  domain: String!
}

type Query {
  currentUser: CurrentUser!
  userPermissionsUserById(id: String!): User!
  userPermissionsUsers(offset: Int! = 0, limit: Int! = 25, search: String, filter: UserFilter, sort: [UserSort!]): PaginatedUserList!
  userPermissionsPermissionList(userId: String!): [UserPermission!]!
  userPermissionsPermission(id: ID!, userId: String): UserPermission!
  userPermissionsAvailablePermissions: [String!]!
  userPermissionsContentScopes(userId: String!, skipManual: Boolean): [JSONObject!]!
  userPermissionsAvailableContentScopes: [JSONObject!]!
  buildTemplates: [BuildTemplate!]!
  builds(limit: Float): [Build!]!
  autoBuildStatus: AutoBuildStatus!
  link(linkId: ID!): Link
  page(id: ID!): Page!
  pageTreeNode(id: ID!): PageTreeNode
  pageTreeNodeByPath(path: String!, scope: PageTreeNodeScopeInput!): PageTreeNode
  pageTreeNodeList(scope: PageTreeNodeScopeInput!, category: String): [PageTreeNode!]!
  paginatedPageTreeNodes(scope: PageTreeNodeScopeInput!, category: String, sort: [PageTreeNodeSort!], offset: Int! = 0, limit: Int! = 25): PaginatedPageTreeNodes!
  pageTreeNodeSlugAvailable(scope: PageTreeNodeScopeInput!, parentId: ID, slug: String!): SlugAvailability!
  redirects(scope: RedirectScopeInput!, query: String, type: RedirectGenerationType, active: Boolean, sortColumnName: String, sortDirection: SortDirection! = ASC): [Redirect!]! @deprecated(reason: "Use paginatedRedirects instead. Will be removed in the next version.")
  paginatedRedirects(scope: RedirectScopeInput!, search: String, filter: RedirectFilter, sort: [RedirectSort!], offset: Int! = 0, limit: Int! = 25): PaginatedRedirects!
  redirect(id: ID!): Redirect!
  redirectSourceAvailable(scope: RedirectScopeInput!, source: String!): Boolean!
  damItemsList(offset: Int! = 0, limit: Int! = 25, sortColumnName: String, sortDirection: SortDirection! = ASC, scope: DamScopeInput!, folderId: ID, includeArchived: Boolean, filter: DamItemFilterInput): PaginatedDamItems!
  damItemListPosition(sortColumnName: String, sortDirection: SortDirection! = ASC, scope: DamScopeInput!, id: ID!, type: DamItemType!, folderId: ID, includeArchived: Boolean, filter: DamItemFilterInput): Int!
  damFilesList(offset: Int! = 0, limit: Int! = 25, sortColumnName: String, sortDirection: SortDirection! = ASC, scope: DamScopeInput!, folderId: ID, includeArchived: Boolean = false, filter: FileFilterInput): PaginatedDamFiles!
  damFile(id: ID!): DamFile!
  findCopiesOfFileInScope(id: ID!, scope: DamScopeInput!, imageCropArea: ImageCropAreaInput): [DamFile!]!
  damIsFilenameOccupied(filename: String!, scope: DamScopeInput!, folderId: String): Boolean!
  damAreFilenamesOccupied(filenames: [FilenameInput!]!, scope: DamScopeInput!): [FilenameResponse!]!
  damFoldersFlat(scope: DamScopeInput!): [DamFolder!]!
  damFoldersList(offset: Int! = 0, limit: Int! = 25, sortColumnName: String, sortDirection: SortDirection! = ASC, scope: DamScopeInput!, parentId: ID, includeArchived: Boolean, filter: FolderFilterInput): PaginatedDamFolders!
  damFolder(id: ID!): DamFolder!
  damFolderByNameAndParentId(scope: DamScopeInput!, name: String!, parentId: ID): DamFolder
  news(id: ID!): News!
  newsBySlug(slug: String!, scope: NewsContentScopeInput!): News
  newsList(offset: Int! = 0, limit: Int! = 25, scope: NewsContentScopeInput!, status: [NewsStatus!]! = [Active], search: String, filter: NewsFilter, sort: [NewsSort!]): PaginatedNews!
  mainMenu(scope: PageTreeNodeScopeInput!): MainMenu!
  topMenu(scope: PageTreeNodeScopeInput!): [PageTreeNode!]!
  mainMenuItem(pageTreeNodeId: ID!): MainMenuItem!
  footer(scope: FooterContentScopeInput!): Footer
  predefinedPage(id: ID!): PredefinedPage
  pageTreeNodeForPredefinedPage(type: String!, scope: PageTreeNodeScopeInput!): PageTreeNode
  kubernetesCronJobs: [KubernetesCronJob!]!
  kubernetesCronJob(name: String!): KubernetesCronJob!
  kubernetesJobs(cronJobName: String!): [KubernetesJob!]!
  kubernetesJob(name: String!): KubernetesJob!
  kubernetesJobLogs(name: String!): String!
  product(id: ID!): Product!
  productBySlug(slug: String!): Product
  products(offset: Int! = 0, limit: Int! = 25, status: [ProductStatus!]! = [Published, Unpublished], search: String, filter: ProductFilter, sort: [ProductSort!]): PaginatedProducts!
  productCategory(id: ID!): ProductCategory!
  productCategoryBySlug(slug: String!): ProductCategory
  productCategories(offset: Int! = 0, limit: Int! = 25, search: String, filter: ProductCategoryFilter, sort: [ProductCategorySort!]): PaginatedProductCategories!
  productTag(id: ID!): ProductTag!
  productTags(offset: Int! = 0, limit: Int! = 25, search: String, filter: ProductTagFilter, sort: [ProductTagSort!]): PaginatedProductTags!
  productVariant(id: ID!): ProductVariant!
  productVariants(offset: Int! = 0, limit: Int! = 25, product: ID!, search: String, filter: ProductVariantFilter, sort: [ProductVariantSort!]): PaginatedProductVariants!
  manufacturer(id: ID!): Manufacturer!
  manufacturers(offset: Int! = 0, limit: Int! = 25, search: String, filter: ManufacturerFilter, sort: [ManufacturerSort!]): PaginatedManufacturers!
  manufacturerCountry(id: ID!): ManufacturerCountry!
  manufacturerCountries(offset: Int! = 0, limit: Int! = 25, search: String, filter: ManufacturerCountryFilter): PaginatedManufacturerCountries!
}

input UserFilter {
  name: StringFilter
  email: StringFilter
  status: StringFilter
  and: [UserFilter!]
  or: [UserFilter!]
}

input StringFilter {
  contains: String
  startsWith: String
  endsWith: String
  equal: String
  notEqual: String
}

input UserSort {
  field: UserSortField!
  direction: SortDirection! = ASC
}

enum UserSortField {
  name
  email
  status
}

enum SortDirection {
  ASC
  DESC
}

input PageTreeNodeSort {
  field: PageTreeNodeSortField!
  direction: SortDirection! = ASC
}

enum PageTreeNodeSortField {
  updatedAt
  pos
}

enum SlugAvailability {
  Available
  Taken
  Reserved
}

input RedirectFilter {
  generationType: StringFilter
  source: StringFilter
  active: BooleanFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  and: [RedirectFilter!]
  or: [RedirectFilter!]
}

input BooleanFilter {
  equal: Boolean
}

input DateTimeFilter {
  equal: DateTime
  lowerThan: DateTime
  greaterThan: DateTime
  lowerThanEqual: DateTime
  greaterThanEqual: DateTime
  notEqual: DateTime
}

input RedirectSort {
  field: RedirectSortField!
  direction: SortDirection! = ASC
}

enum RedirectSortField {
  source
  createdAt
  updatedAt
}

input DamItemFilterInput {
  searchText: String
  mimetypes: [String!]
}

enum DamItemType {
  File
  Folder
}

input FileFilterInput {
  searchText: String
  mimetypes: [String!]
}

input ImageCropAreaInput {
  focalPoint: FocalPoint!
  width: Float
  height: Float
  x: Float
  y: Float
}

input FilenameInput {
  name: String!
  folderId: ID
}

input FolderFilterInput {
  searchText: String
}

input NewsFilter {
  slug: StringFilter
  title: StringFilter
  status: NewsStatusEnumFilter
  date: DateTimeFilter
  category: NewsCategoryEnumFilter
  comments: OneToManyFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  and: [NewsFilter!]
  or: [NewsFilter!]
}

input NewsStatusEnumFilter {
  isAnyOf: [NewsStatus!]
  equal: NewsStatus
  notEqual: NewsStatus
}

input NewsCategoryEnumFilter {
  isAnyOf: [NewsCategory!]
  equal: NewsCategory
  notEqual: NewsCategory
}

input OneToManyFilter {
  contains: ID
}

input NewsSort {
  field: NewsSortField!
  direction: SortDirection! = ASC
}

enum NewsSortField {
  slug
  title
  status
  date
  category
  createdAt
  updatedAt
}

input ProductFilter {
  title: StringFilter
  status: ProductStatusEnumFilter
  slug: StringFilter
  description: StringFilter
  type: ProductTypeEnumFilter
  additionalTypes: ProductTypeEnumsFilter
  price: NumberFilter
  inStock: BooleanFilter
  soldCount: NumberFilter
  availableSince: DateTimeFilter
  colors: OneToManyFilter
  variants: OneToManyFilter
  category: ManyToOneFilter
  tags: ManyToManyFilter
  tagsWithStatus: OneToManyFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  manufacturer: ManyToOneFilter
  and: [ProductFilter!]
  or: [ProductFilter!]
}

input ProductStatusEnumFilter {
  isAnyOf: [ProductStatus!]
  equal: ProductStatus
  notEqual: ProductStatus
}

input ProductTypeEnumFilter {
  isAnyOf: [ProductType!]
  equal: ProductType
  notEqual: ProductType
}

input ProductTypeEnumsFilter {
  contains: [ProductType!]
}

input NumberFilter {
  equal: Float
  lowerThan: Float
  greaterThan: Float
  lowerThanEqual: Float
  greaterThanEqual: Float
  notEqual: Float
}

input ManyToOneFilter {
  isAnyOf: [ID!]
  equal: ID
  notEqual: ID
}

input ManyToManyFilter {
  contains: ID
}

input ProductSort {
  field: ProductSortField!
  direction: SortDirection! = ASC
}

enum ProductSortField {
  title
  status
  slug
  description
  type
  additionalTypes
  price
  inStock
  soldCount
  availableSince
  category
  createdAt
  updatedAt
  manufacturer
}

input ProductCategoryFilter {
  title: StringFilter
  slug: StringFilter
  products: OneToManyFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  and: [ProductCategoryFilter!]
  or: [ProductCategoryFilter!]
}

input ProductCategorySort {
  field: ProductCategorySortField!
  direction: SortDirection! = ASC
}

enum ProductCategorySortField {
  title
  slug
  position
  createdAt
  updatedAt
}

input ProductTagFilter {
  title: StringFilter
  products: ManyToManyFilter
  productsWithStatus: OneToManyFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  and: [ProductTagFilter!]
  or: [ProductTagFilter!]
}

input ProductTagSort {
  field: ProductTagSortField!
  direction: SortDirection! = ASC
}

enum ProductTagSortField {
  title
  createdAt
  updatedAt
}

input ProductVariantFilter {
  name: StringFilter
  createdAt: DateTimeFilter
  updatedAt: DateTimeFilter
  and: [ProductVariantFilter!]
  or: [ProductVariantFilter!]
}

input ProductVariantSort {
  field: ProductVariantSortField!
  direction: SortDirection! = ASC
}

enum ProductVariantSortField {
  name
  product
  createdAt
  updatedAt
}

input ManufacturerFilter {
  name: StringFilter
  addressAsEmbeddable_street: StringFilter
  addressAsEmbeddable_streetNumber: NumberFilter
  addressAsEmbeddable_zip: NumberFilter
  addressAsEmbeddable_country: StringFilter
  addressAsEmbeddable_alternativeAddress_street: StringFilter
  addressAsEmbeddable_alternativeAddress_streetNumber: NumberFilter
  addressAsEmbeddable_alternativeAddress_zip: NumberFilter
  addressAsEmbeddable_alternativeAddress_country: StringFilter
  updatedAt: DateTimeFilter
  and: [ManufacturerFilter!]
  or: [ManufacturerFilter!]
}

input ManufacturerSort {
  field: ManufacturerSortField!
  direction: SortDirection! = ASC
}

enum ManufacturerSortField {
  name
  addressAsEmbeddable_street
  addressAsEmbeddable_streetNumber
  addressAsEmbeddable_zip
  addressAsEmbeddable_country
  addressAsEmbeddable_alternativeAddress_street
  addressAsEmbeddable_alternativeAddress_streetNumber
  addressAsEmbeddable_alternativeAddress_zip
  addressAsEmbeddable_alternativeAddress_country
  updatedAt
}

input ManufacturerCountryFilter {
  id: StringFilter
  used: NumberFilter
  and: [ManufacturerCountryFilter!]
  or: [ManufacturerCountryFilter!]
}

type Mutation {
  currentUserSignOut: String!
  userPermissionsCreatePermission(userId: String!, input: UserPermissionInput!): UserPermission!
  userPermissionsUpdatePermission(id: String!, input: UserPermissionInput!): UserPermission!
  userPermissionsDeletePermission(id: ID!): Boolean!
  userPermissionsUpdateOverrideContentScopes(input: UserPermissionOverrideContentScopesInput!): UserPermission!
  userPermissionsUpdateContentScopes(userId: String!, input: UserContentScopesInput!): Boolean!
  createBuilds(input: CreateBuildsInput!): Boolean!
  saveLink(linkId: ID!, input: LinkInput!, attachedPageTreeNodeId: ID!, lastUpdatedAt: DateTime): Link!
  savePage(pageId: ID!, input: PageInput!, attachedPageTreeNodeId: ID!, lastUpdatedAt: DateTime): Page!
  updatePageTreeNode(id: ID!, input: PageTreeNodeUpdateInput!): PageTreeNode!
  deletePageTreeNode(id: ID!): Boolean!
  updatePageTreeNodeVisibility(id: ID!, input: PageTreeNodeUpdateVisibilityInput!): PageTreeNode!
  updatePageTreeNodeSlug(id: ID!, slug: String!): PageTreeNode!
  movePageTreeNodesByPos(ids: [ID!]!, input: MovePageTreeNodesByPosInput!): [PageTreeNode!]!
  movePageTreeNodesByNeighbour(ids: [ID!]!, input: MovePageTreeNodesByNeighbourInput!): [PageTreeNode!]!
  updatePageTreeNodeCategory(id: ID!, category: String!): PageTreeNode!
  createPageTreeNode(input: PageTreeNodeCreateInput!, scope: PageTreeNodeScopeInput!, category: String!): PageTreeNode!
  createRedirect(scope: RedirectScopeInput!, input: RedirectInput!): Redirect!
  updateRedirect(id: ID!, input: RedirectInput!, lastUpdatedAt: DateTime): Redirect!
  updateRedirectActiveness(id: ID!, input: RedirectUpdateActivenessInput!): Redirect!
  deleteRedirect(id: ID!): Boolean!
  updateDamFile(id: ID!, input: UpdateDamFileInput!): DamFile!
  importDamFileByDownload(url: String!, scope: DamScopeInput!, input: UpdateDamFileInput!): DamFile!
  moveDamFiles(fileIds: [ID!]!, targetFolderId: ID): [DamFile!]!
  copyFilesToScope(fileIds: [ID!]!, inboxFolderId: ID!): CopyFilesResponse!
  archiveDamFile(id: ID!): DamFile!
  archiveDamFiles(ids: [ID!]!): [DamFile!]!
  restoreDamFile(id: ID!): DamFile!
  restoreDamFiles(ids: [ID!]!): [DamFile!]!
  deleteDamFile(id: ID!): Boolean!
  createDamFolder(input: CreateDamFolderInput!, scope: DamScopeInput!): DamFolder!
  updateDamFolder(id: ID!, input: UpdateDamFolderInput!): DamFolder!
  moveDamFolders(folderIds: [ID!]!, targetFolderId: ID, scope: DamScopeInput!): [DamFolder!]!
  deleteDamFolder(id: ID!): Boolean!
  createNews(scope: NewsContentScopeInput!, input: NewsInput!): News!
  updateNews(id: ID!, input: NewsUpdateInput!): News!
  deleteNews(id: ID!): Boolean!
  createNewsComment(newsId: ID!, input: NewsCommentInput!): NewsComment!
  updateNewsComment(id: ID!, input: NewsCommentInput!): NewsComment!
  deleteNewsComment(id: ID!): Boolean!
  updateMainMenuItem(pageTreeNodeId: ID!, input: MainMenuItemInput!, lastUpdatedAt: DateTime): MainMenuItem!
  saveFooter(scope: FooterContentScopeInput!, input: FooterInput!): Footer!
  savePredefinedPage(id: ID!, input: PredefinedPageInput!, attachedPageTreeNodeId: ID!, lastUpdatedAt: DateTime): PredefinedPage!
  triggerKubernetesCronJob(name: String!): KubernetesJob!
  createProduct(input: ProductInput!): Product!
  updateProduct(id: ID!, input: ProductUpdateInput!): Product!
  deleteProduct(id: ID!): Boolean!
  createProductCategory(input: ProductCategoryInput!): ProductCategory!
  updateProductCategory(id: ID!, input: ProductCategoryUpdateInput!): ProductCategory!
  deleteProductCategory(id: ID!): Boolean!
  createProductTag(input: ProductTagInput!): ProductTag!
  updateProductTag(id: ID!, input: ProductTagUpdateInput!): ProductTag!
  deleteProductTag(id: ID!): Boolean!
  createProductVariant(product: ID!, input: ProductVariantInput!): ProductVariant!
  updateProductVariant(id: ID!, input: ProductVariantUpdateInput!): ProductVariant!
  deleteProductVariant(id: ID!): Boolean!
  createManufacturer(input: ManufacturerInput!): Manufacturer!
  updateManufacturer(id: ID!, input: ManufacturerUpdateInput!): Manufacturer!
  deleteManufacturer(id: ID!): Boolean!
}

input UserPermissionInput {
  permission: String!
  validFrom: DateTime
  validTo: DateTime
  reason: String
  requestedBy: String
  approvedBy: String
}

input UserPermissionOverrideContentScopesInput {
  permissionId: ID!
  overrideContentScopes: Boolean!
  contentScopes: [JSONObject!]! = []
}

input UserContentScopesInput {
  contentScopes: [JSONObject!]! = []
}

input CreateBuildsInput {
  names: [String!]!
}

input LinkInput {
  content: LinkBlockInput!
}

"""Link root block input"""
scalar LinkBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input PageInput {
  content: PageContentBlockInput!
  seo: SeoBlockInput!
}

"""PageContent root block input"""
scalar PageContentBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""Seo root block input"""
scalar SeoBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input PageTreeNodeUpdateInput {
  name: String!
  slug: String!
  attachedDocument: AttachedDocumentInput
  hideInMenu: Boolean
  createAutomaticRedirectsOnSlugChange: Boolean = true
  userGroup: UserGroup! = All
}

input AttachedDocumentInput {
  type: String!
  id: String
}

input PageTreeNodeUpdateVisibilityInput {
  visibility: PageTreeNodeVisibility!
}

input MovePageTreeNodesByPosInput {
  parentId: String
  pos: Int!
}

input MovePageTreeNodesByNeighbourInput {
  parentId: String
  afterId: String
  beforeId: String
}

input PageTreeNodeCreateInput {
  id: ID
  name: String!
  parentId: String
  pos: Int
  slug: String!
  attachedDocument: AttachedDocumentInput!
  hideInMenu: Boolean
  userGroup: UserGroup! = All
}

input RedirectInput {
  sourceType: RedirectSourceTypeValues!
  source: String!
  target: JSONObject!
  comment: String
  active: Boolean
  generationType: RedirectGenerationType!
}

input RedirectUpdateActivenessInput {
  active: Boolean!
}

input UpdateDamFileInput {
  name: String
  title: String
  altText: String
  image: UpdateImageFileInput
  folderId: ID
  license: LicenseInput
}

input UpdateImageFileInput {
  cropArea: ImageCropAreaInput
}

input LicenseInput {
  type: LicenseType
  details: String
  author: String
  durationFrom: DateTime
  durationTo: DateTime
}

input CreateDamFolderInput {
  name: String!
  parentId: ID
  isInboxFromOtherScope: Boolean! = false
}

input UpdateDamFolderInput {
  name: String
  parentId: ID
  archived: Boolean
}

input NewsInput {
  slug: String!
  title: String!
  status: NewsStatus! = Active
  date: DateTime!
  category: NewsCategory! = Awards
  image: DamImageBlockInput!
  content: NewsContentBlockInput!
}

"""DamImage root block input"""
scalar DamImageBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""NewsContent root block input"""
scalar NewsContentBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input NewsUpdateInput {
  slug: String
  title: String
  status: NewsStatus
  date: DateTime
  category: NewsCategory
  image: DamImageBlockInput
  content: NewsContentBlockInput
}

input NewsCommentInput {
  comment: String!
}

input MainMenuItemInput {
  content: RichTextBlockInput
}

"""RichText root block input"""
scalar RichTextBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input FooterInput {
  content: FooterContentBlockInput!
}

"""FooterContent root block input"""
scalar FooterContentBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input PredefinedPageInput {
  type: String
}

input ProductInput {
  title: String!
  status: ProductStatus! = Unpublished
  slug: String!
  description: String!
  type: ProductType!
  additionalTypes: [ProductType!]! = []
  price: Float = null
  inStock: Boolean! = true
  availableSince: DateTime = null
  image: DamImageBlockInput!
  discounts: [ProductDiscountsInput!]! = []
  articleNumbers: [String!]! = []
  dimensions: ProductDimensionsInput
  statistics: ProductNestedProductStatisticsInput
  colors: [ProductNestedProductColorInput!]! = []
  category: ID = null
  tags: [ID!]! = []
  tagsWithStatus: [ProductNestedProductToTagInput!]! = []
  manufacturer: ID = null
}

input ProductNestedProductStatisticsInput {
  views: Int!
}

input ProductNestedProductColorInput {
  name: String!
  hexCode: String!
}

input ProductNestedProductToTagInput {
  tag: ID!
  exampleStatus: Boolean! = true
}

input ProductUpdateInput {
  title: String
  status: ProductStatus
  slug: String
  description: String
  type: ProductType
  additionalTypes: [ProductType!]
  price: Float
  inStock: Boolean
  availableSince: DateTime
  image: DamImageBlockInput
  discounts: [ProductDiscountsInput!]
  articleNumbers: [String!]
  dimensions: ProductDimensionsInput
  statistics: ProductNestedProductStatisticsInput
  colors: [ProductNestedProductColorInput!]
  category: ID
  tags: [ID!]
  tagsWithStatus: [ProductNestedProductToTagInput!]
  manufacturer: ID
}

input ProductCategoryInput {
  title: String!
  slug: String!
  position: Int
}

input ProductCategoryUpdateInput {
  title: String
  slug: String
  position: Int
}

input ProductTagInput {
  title: String!
  products: [ID!]! = []
  productsWithStatus: [ProductTagNestedProductToTagInput!]! = []
}

input ProductTagNestedProductToTagInput {
  product: ID!
  exampleStatus: Boolean! = true
}

input ProductTagUpdateInput {
  title: String
  products: [ID!]
  productsWithStatus: [ProductTagNestedProductToTagInput!]
}

input ProductVariantInput {
  name: String!
  image: DamImageBlockInput!
}

input ProductVariantUpdateInput {
  name: String
  image: DamImageBlockInput
}

input ManufacturerInput {
  name: String!
  address: AddressInput
  addressAsEmbeddable: AddressAsEmbeddableInput!
}

input ManufacturerUpdateInput {
  name: String
  address: AddressInput
  addressAsEmbeddable: AddressAsEmbeddableInput
}
