// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { extractGraphqlFields, SubjectEntity } from "@comet/cms-api";
import { FindOptions, Reference } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Parent, Query, ResolveField, Resolver } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";

import { ShopProduct } from "../entities/shop-product.entity";
import { ShopProductCategory } from "../entities/shop-product-category.entitiy";
import { ShopProductVariant } from "../entities/shop-product-variant.entity";
import { PaginatedShopProducts } from "./dto/paginated-shop-products";
import { ShopProductInput, ShopProductUpdateInput } from "./dto/shop-product.input";
import { ShopProductsArgs } from "./dto/shop-products.args";
import { ShopProductsService } from "./shop-products.service";

@Resolver(() => ShopProduct)
export class ShopProductResolver {
    constructor(
        private readonly entityManager: EntityManager,
        private readonly shopProductsService: ShopProductsService,
        @InjectRepository(ShopProduct) private readonly repository: EntityRepository<ShopProduct>,
        @InjectRepository(ShopProductVariant) private readonly shopProductVariantRepository: EntityRepository<ShopProductVariant>,
        @InjectRepository(ShopProductCategory) private readonly shopProductCategoryRepository: EntityRepository<ShopProductCategory>,
    ) {}

    @Query(() => ShopProduct)
    @SubjectEntity(ShopProduct)
    async shopProduct(@Args("id", { type: () => ID }) id: string): Promise<ShopProduct> {
        const shopProduct = await this.repository.findOneOrFail(id);
        return shopProduct;
    }

    @Query(() => PaginatedShopProducts)
    async shopProducts(
        @Args() { search, filter, sort, offset, limit }: ShopProductsArgs,
        @Info() info: GraphQLResolveInfo,
    ): Promise<PaginatedShopProducts> {
        const where = this.shopProductsService.getFindCondition({ search, filter });

        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("variants")) {
            populate.push("variants");
        }
        if (fields.includes("category")) {
            populate.push("category");
        }

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<ShopProduct, any> = { offset, limit, populate };

        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedShopProducts(entities, totalCount);
    }

    @Mutation(() => ShopProduct)
    async createShopProduct(@Args("input", { type: () => ShopProductInput }) input: ShopProductInput): Promise<ShopProduct> {
        const { variants: variantsInput, category: categoryInput, ...assignInput } = input;
        const shopProduct = this.repository.create({
            ...assignInput,
        });

        if (variantsInput) {
            const variants = await this.shopProductVariantRepository.find({ id: variantsInput });
            if (variants.length != variantsInput.length) throw new Error("Couldn't find all variants that were passed as input");
            await shopProduct.variants.loadItems();
            shopProduct.variants.set(variants.map((variant) => Reference.create(variant)));
        }
        if (categoryInput) {
            const category = await this.shopProductCategoryRepository.find({ id: categoryInput });
            if (category.length != categoryInput.length) throw new Error("Couldn't find all category that were passed as input");
            await shopProduct.category.loadItems();
            shopProduct.category.set(category.map((category) => Reference.create(category)));
        }

        await this.entityManager.flush();

        return shopProduct;
    }

    @Mutation(() => ShopProduct)
    @SubjectEntity(ShopProduct)
    async updateShopProduct(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => ShopProductUpdateInput }) input: ShopProductUpdateInput,
    ): Promise<ShopProduct> {
        const shopProduct = await this.repository.findOneOrFail(id);

        const { variants: variantsInput, category: categoryInput, ...assignInput } = input;
        shopProduct.assign({
            ...assignInput,
        });

        if (variantsInput) {
            const variants = await this.shopProductVariantRepository.find({ id: variantsInput });
            if (variants.length != variantsInput.length) throw new Error("Couldn't find all variants that were passed as input");
            await shopProduct.variants.loadItems();
            shopProduct.variants.set(variants.map((variant) => Reference.create(variant)));
        }
        if (categoryInput) {
            const category = await this.shopProductCategoryRepository.find({ id: categoryInput });
            if (category.length != categoryInput.length) throw new Error("Couldn't find all category that were passed as input");
            await shopProduct.category.loadItems();
            shopProduct.category.set(category.map((category) => Reference.create(category)));
        }

        await this.entityManager.flush();

        return shopProduct;
    }

    @Mutation(() => Boolean)
    @SubjectEntity(ShopProduct)
    async deleteShopProduct(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const shopProduct = await this.repository.findOneOrFail(id);
        await this.entityManager.remove(shopProduct);
        await this.entityManager.flush();
        return true;
    }

    @ResolveField(() => [ShopProductVariant])
    async variants(@Parent() shopProduct: ShopProduct): Promise<ShopProductVariant[]> {
        return shopProduct.variants.loadItems();
    }

    @ResolveField(() => [ShopProductCategory])
    async category(@Parent() shopProduct: ShopProduct): Promise<ShopProductCategory[]> {
        return shopProduct.category.loadItems();
    }
}
