// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { AffectedEntity, gqlArgsToMikroOrmQuery, RequiredPermission } from "@comet/cms-api";
import { FindOptions } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Mutation, Query, Resolver } from "@nestjs/graphql";

import { Warning } from "../entities/warning.entity";
import { PaginatedWarnings } from "./dto/paginated-warnings";
import { WarningInput, WarningUpdateInput } from "./dto/warning.input";
import { WarningsArgs } from "./dto/warnings.args";

@Resolver(() => Warning)
@RequiredPermission(["pageTree"], { skipScopeCheck: true })
export class WarningResolver {
    constructor(private readonly entityManager: EntityManager, @InjectRepository(Warning) private readonly repository: EntityRepository<Warning>) {}

    @Query(() => Warning)
    @AffectedEntity(Warning)
    async warning(@Args("id", { type: () => ID }) id: string): Promise<Warning> {
        const warning = await this.repository.findOneOrFail(id);
        return warning;
    }

    @Query(() => PaginatedWarnings)
    async warnings(@Args() { search, filter, sort, offset, limit }: WarningsArgs): Promise<PaginatedWarnings> {
        const where = gqlArgsToMikroOrmQuery({ search, filter }, this.repository);

        const options: FindOptions<Warning> = { offset, limit };

        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedWarnings(entities, totalCount);
    }

    @Mutation(() => Warning)
    async createWarning(@Args("input", { type: () => WarningInput }) input: WarningInput): Promise<Warning> {
        const warning = this.repository.create({
            ...input,
        });

        await this.entityManager.flush();

        return warning;
    }

    @Mutation(() => Warning)
    @AffectedEntity(Warning)
    async updateWarning(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => WarningUpdateInput }) input: WarningUpdateInput,
    ): Promise<Warning> {
        const warning = await this.repository.findOneOrFail(id);

        warning.assign({
            ...input,
        });

        await this.entityManager.flush();

        return warning;
    }

    @Mutation(() => Boolean)
    @AffectedEntity(Warning)
    async deleteWarning(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const warning = await this.repository.findOneOrFail(id);
        this.entityManager.remove(warning);
        await this.entityManager.flush();
        return true;
    }
}
