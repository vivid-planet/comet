// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { SubjectEntity, validateNotModified } from "@comet/cms-api";
import { FindOptions } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Mutation, Query, Resolver } from "@nestjs/graphql";

import { Book } from "../entities/book.entity";
import { BooksService } from "./books.service";
import { BookInput, BookUpdateInput } from "./dto/book.input";
import { BooksArgs } from "./dto/books.args";
import { PaginatedBooks } from "./dto/paginated-books";

@Resolver(() => Book)
export class BookResolver {
    constructor(
        private readonly entityManager: EntityManager,
        private readonly booksService: BooksService,
        @InjectRepository(Book) private readonly repository: EntityRepository<Book>,
    ) {}

    @Query(() => Book)
    @SubjectEntity(Book)
    async book(@Args("id", { type: () => ID }) id: string): Promise<Book> {
        const book = await this.repository.findOneOrFail(id);
        return book;
    }

    @Query(() => PaginatedBooks)
    async books(@Args() { search, filter, sort, offset, limit }: BooksArgs): Promise<PaginatedBooks> {
        const where = this.booksService.getFindCondition({ search, filter });

        const options: FindOptions<Book> = { offset, limit };

        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedBooks(entities, totalCount);
    }

    @Mutation(() => Book)
    async createBook(@Args("input", { type: () => BookInput }) input: BookInput): Promise<Book> {
        const { coverImage: coverImageInput, link: linkInput, ...assignInput } = input;
        const book = this.repository.create({
            ...assignInput,

            coverImage: coverImageInput.transformToBlockData(),
            link: linkInput.transformToBlockData(),
        });

        await this.entityManager.flush();

        return book;
    }

    @Mutation(() => Book)
    @SubjectEntity(Book)
    async updateBook(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => BookUpdateInput }) input: BookUpdateInput,
        @Args("lastUpdatedAt", { type: () => Date, nullable: true }) lastUpdatedAt?: Date,
    ): Promise<Book> {
        const book = await this.repository.findOneOrFail(id);
        if (lastUpdatedAt) {
            validateNotModified(book, lastUpdatedAt);
        }

        const { coverImage: coverImageInput, link: linkInput, ...assignInput } = input;
        book.assign({
            ...assignInput,
        });

        if (coverImageInput) {
            book.coverImage = coverImageInput.transformToBlockData();
        }
        if (linkInput) {
            book.link = linkInput.transformToBlockData();
        }

        await this.entityManager.flush();

        return book;
    }

    @Mutation(() => Boolean)
    @SubjectEntity(Book)
    async deleteBook(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const book = await this.repository.findOneOrFail(id);
        await this.entityManager.remove(book);
        await this.entityManager.flush();
        return true;
    }
}
