// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { AffectedEntity, extractGraphqlFields, gqlArgsToMikroOrmQuery, RequiredPermission } from "@comet/cms-api";
import { FindOptions, Reference } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Parent, Query, ResolveField, Resolver } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";

import { FormBuilder } from "../entities/form-builder.entity";
import { FormRequest } from "../entities/form-request.entity";
import { FormRequestInput, FormRequestUpdateInput } from "./dto/form-request.input";
import { FormRequestsArgs } from "./dto/form-requests.args";
import { PaginatedFormRequests } from "./dto/paginated-form-requests";

@Resolver(() => FormRequest)
@RequiredPermission("disablePermissionCheck", { skipScopeCheck: true })
export class FormRequestResolver {
    constructor(
        private readonly entityManager: EntityManager,
        @InjectRepository(FormRequest) private readonly repository: EntityRepository<FormRequest>,
        @InjectRepository(FormBuilder) private readonly formBuilderRepository: EntityRepository<FormBuilder>,
    ) {}

    @Query(() => FormRequest)
    @AffectedEntity(FormRequest)
    async formRequest(@Args("id", { type: () => ID }) id: string): Promise<FormRequest> {
        const formRequest = await this.repository.findOneOrFail(id);
        return formRequest;
    }

    @Query(() => PaginatedFormRequests)
    async formRequests(
        @Args() { search, filter, sort, offset, limit }: FormRequestsArgs,
        @Info() info: GraphQLResolveInfo,
    ): Promise<PaginatedFormRequests> {
        const where = gqlArgsToMikroOrmQuery({ search, filter }, this.repository);

        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("form")) {
            populate.push("form");
        }

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<FormRequest, any> = { offset, limit, populate };

        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedFormRequests(entities, totalCount);
    }

    @Mutation(() => FormRequest)
    async createFormRequest(@Args("input", { type: () => FormRequestInput }) input: FormRequestInput): Promise<FormRequest> {
        const { form: formInput, ...assignInput } = input;
        const formRequest = this.repository.create({
            ...assignInput,

            form: Reference.create(await this.formBuilderRepository.findOneOrFail(formInput)),
        });

        await this.entityManager.flush();

        return formRequest;
    }

    @Mutation(() => FormRequest)
    @AffectedEntity(FormRequest)
    async updateFormRequest(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => FormRequestUpdateInput }) input: FormRequestUpdateInput,
    ): Promise<FormRequest> {
        const formRequest = await this.repository.findOneOrFail(id);

        const { form: formInput, ...assignInput } = input;
        formRequest.assign({
            ...assignInput,
        });

        if (formInput !== undefined) {
            formRequest.form = Reference.create(await this.formBuilderRepository.findOneOrFail(formInput));
        }

        await this.entityManager.flush();

        return formRequest;
    }

    @Mutation(() => Boolean)
    @AffectedEntity(FormRequest)
    async deleteFormRequest(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const formRequest = await this.repository.findOneOrFail(id);
        this.entityManager.remove(formRequest);
        await this.entityManager.flush();
        return true;
    }

    @ResolveField(() => FormBuilder)
    async form(@Parent() formRequest: FormRequest): Promise<FormBuilder> {
        return formRequest.form.load();
    }
}
