// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import {
    AffectedEntity,
    BlocksTransformerService,
    extractGraphqlFields,
    gqlArgsToMikroOrmQuery,
    RequiredPermission,
    RootBlockDataScalar,
} from "@comet/cms-api";
import { FindOptions, Reference } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Parent, Query, ResolveField, Resolver } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";

import { FormBuilderBlock } from "../blocks/form-builder.block";
import { FormBuilder, FormBuilderContentScope } from "../entities/form-builder.entity";
import { FormRequest } from "../entities/form-request.entity";
import { FormBuilderInput, FormBuilderUpdateInput } from "./dto/form-builder.input";
import { FormBuildersArgs } from "./dto/form-builders.args";
import { PaginatedFormBuilders } from "./dto/paginated-form-builders";

@Resolver(() => FormBuilder)
@RequiredPermission(["formBuilders"])
export class FormBuilderResolver {
    constructor(
        private readonly entityManager: EntityManager,
        @InjectRepository(FormBuilder) private readonly repository: EntityRepository<FormBuilder>,
        @InjectRepository(FormRequest) private readonly formRequestRepository: EntityRepository<FormRequest>,
        private readonly blocksTransformer: BlocksTransformerService,
    ) {}

    @Query(() => FormBuilder)
    @AffectedEntity(FormBuilder)
    async formBuilder(@Args("id", { type: () => ID }) id: string): Promise<FormBuilder> {
        const formBuilder = await this.repository.findOneOrFail(id);
        return formBuilder;
    }

    @Query(() => PaginatedFormBuilders)
    async formBuilders(
        @Args() { scope, search, filter, sort, offset, limit }: FormBuildersArgs,
        @Info() info: GraphQLResolveInfo,
    ): Promise<PaginatedFormBuilders> {
        const where = gqlArgsToMikroOrmQuery({ search, filter }, this.repository);

        where.scope = scope;

        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("requests")) {
            populate.push("requests");
        }

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<FormBuilder, any> = { offset, limit, populate };

        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedFormBuilders(entities, totalCount);
    }

    @Mutation(() => FormBuilder)
    async createFormBuilder(
        @Args("scope", { type: () => FormBuilderContentScope }) scope: FormBuilderContentScope,
        @Args("input", { type: () => FormBuilderInput }) input: FormBuilderInput,
    ): Promise<FormBuilder> {
        const { requests: requestsInput, blocks: blocksInput, ...assignInput } = input;
        const formBuilder = this.repository.create({
            ...assignInput,
            scope,

            blocks: blocksInput.transformToBlockData(),
        });

        if (requestsInput) {
            const requests = await this.formRequestRepository.find({ id: requestsInput });
            if (requests.length != requestsInput.length) throw new Error("Couldn't find all requests that were passed as input");
            await formBuilder.requests.loadItems();
            formBuilder.requests.set(requests.map((request) => Reference.create(request)));
        }

        await this.entityManager.flush();

        return formBuilder;
    }

    @Mutation(() => FormBuilder)
    @AffectedEntity(FormBuilder)
    async updateFormBuilder(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => FormBuilderUpdateInput }) input: FormBuilderUpdateInput,
    ): Promise<FormBuilder> {
        const formBuilder = await this.repository.findOneOrFail(id);

        const { requests: requestsInput, blocks: blocksInput, ...assignInput } = input;
        formBuilder.assign({
            ...assignInput,
        });

        if (requestsInput) {
            const requests = await this.formRequestRepository.find({ id: requestsInput });
            if (requests.length != requestsInput.length) throw new Error("Couldn't find all requests that were passed as input");
            await formBuilder.requests.loadItems();
            formBuilder.requests.set(requests.map((request) => Reference.create(request)));
        }

        if (blocksInput) {
            formBuilder.blocks = blocksInput.transformToBlockData();
        }

        await this.entityManager.flush();

        return formBuilder;
    }

    @Mutation(() => Boolean)
    @AffectedEntity(FormBuilder)
    async deleteFormBuilder(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const formBuilder = await this.repository.findOneOrFail(id);
        this.entityManager.remove(formBuilder);
        await this.entityManager.flush();
        return true;
    }

    @ResolveField(() => [FormRequest])
    async requests(@Parent() formBuilder: FormBuilder): Promise<FormRequest[]> {
        return formBuilder.requests.loadItems();
    }

    @ResolveField(() => RootBlockDataScalar(FormBuilderBlock))
    async blocks(@Parent() formBuilder: FormBuilder): Promise<object> {
        return this.blocksTransformer.transformToPlain(formBuilder.blocks);
    }
}
