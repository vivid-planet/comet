// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { EntityManager, FindOptions, Reference } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Query, Resolver, ResolveField, Parent } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";
import { BazInput, BazUpdateInput } from "./dto/baz.input";
import { PaginatedBazs } from "./dto/paginated-bazs";
import { BazsArgs } from "./dto/bazs.args";
import { Bar } from "../entities/bar.entity";
import { Baz } from "../entities/baz.entity";
import { AffectedEntity, RequiredPermission, extractGraphqlFields, gqlArgsToMikroOrmQuery, gqlSortToMikroOrmOrderBy } from "@comet/cms-api";
@Resolver(() => Baz)
@RequiredPermission(["pageTree"], { skipScopeCheck: true })
export class BazResolver {
    constructor(protected readonly entityManager: EntityManager) { }
    @Query(() => Baz)
    @AffectedEntity(Baz)
    async baz(
    @Args("id", { type: () => ID })
    id: string): Promise<Baz> {
        const baz = await this.entityManager.findOneOrFail(Baz, id);
        return baz;
    }
    @Query(() => PaginatedBazs)
    async bazs(
    @Args()
    { search, filter, sort, offset, limit }: BazsArgs, 
    @Info()
    info: GraphQLResolveInfo): Promise<PaginatedBazs> {
        const where = gqlArgsToMikroOrmQuery({ search, filter, }, this.entityManager.getMetadata(Baz));
        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("bar")) {
            populate.push("bar");
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<Baz, any> = { offset, limit, populate };
        if (sort) {
            options.orderBy = gqlSortToMikroOrmOrderBy(sort);
        }
        const [entities, totalCount] = await this.entityManager.findAndCount(Baz, where, options);
        return new PaginatedBazs(entities, totalCount);
    }
    @Mutation(() => Baz)
    async createBaz(
    @Args("input", { type: () => BazInput })
    input: BazInput): Promise<Baz> {
        const { bar: barInput, ...assignInput } = input;
        const baz = this.entityManager.create(Baz, {
            ...assignInput,
            bar: Reference.create(await this.entityManager.findOneOrFail(Bar, barInput)),
        });
        await this.entityManager.flush();
        return baz;
    }
    @Mutation(() => Baz)
    @AffectedEntity(Baz)
    async updateBaz(
    @Args("id", { type: () => ID })
    id: string, 
    @Args("input", { type: () => BazUpdateInput })
    input: BazUpdateInput): Promise<Baz> {
        const baz = await this.entityManager.findOneOrFail(Baz, id);
        const { bar: barInput, ...assignInput } = input;
        baz.assign({
            ...assignInput,
        });
        if (barInput !== undefined) {
            baz.bar =
                Reference.create(await this.entityManager.findOneOrFail(Bar, barInput));
        }
        await this.entityManager.flush();
        return baz;
    }
    @Mutation(() => Boolean)
    @AffectedEntity(Baz)
    async deleteBaz(
    @Args("id", { type: () => ID })
    id: string): Promise<boolean> {
        const baz = await this.entityManager.findOneOrFail(Baz, id);
        this.entityManager.remove(baz);
        await this.entityManager.flush();
        return true;
    }
    @ResolveField(() => Bar)
    async bar(
    @Parent()
    baz: Baz): Promise<Bar> {
        return baz.bar.loadOrFail();
    }
}
