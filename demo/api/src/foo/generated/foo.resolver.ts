// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { EntityManager, FindOptions } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Query, Resolver, ResolveField, Parent } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";
import { FooInput, FooUpdateInput } from "./dto/foo.input";
import { PaginatedFoos } from "./dto/paginated-foos";
import { FoosArgs } from "./dto/foos.args";
import { Bar } from "../entities/bar.entity";
import { Foo } from "../entities/foo.entity";
import { AffectedEntity, RequiredPermission, extractGraphqlFields, gqlArgsToMikroOrmQuery, gqlSortToMikroOrmOrderBy } from "@comet/cms-api";
@Resolver(() => Foo)
@RequiredPermission(["pageTree"], { skipScopeCheck: true })
export class FooResolver {
    constructor(protected readonly entityManager: EntityManager) { }
    @Query(() => Foo)
    @AffectedEntity(Foo)
    async foo(
    @Args("id", { type: () => ID })
    id: string): Promise<Foo> {
        const foo = await this.entityManager.findOneOrFail(Foo, id);
        return foo;
    }
    @Query(() => PaginatedFoos)
    async foos(
    @Args()
    { search, filter, sort, offset, limit }: FoosArgs, 
    @Info()
    info: GraphQLResolveInfo): Promise<PaginatedFoos> {
        const where = gqlArgsToMikroOrmQuery({ search, filter, }, this.entityManager.getMetadata(Foo));
        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("bars")) {
            populate.push("bars");
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<Foo, any> = { offset, limit, populate };
        if (sort) {
            options.orderBy = gqlSortToMikroOrmOrderBy(sort);
        }
        const [entities, totalCount] = await this.entityManager.findAndCount(Foo, where, options);
        return new PaginatedFoos(entities, totalCount);
    }
    @Mutation(() => Foo)
    async createFoo(
    @Args("input", { type: () => FooInput })
    input: FooInput): Promise<Foo> {
        const { bars: barsInput, ...assignInput } = input;
        const foo = this.entityManager.create(Foo, {
            ...assignInput,
        });
        if (barsInput) {
            await foo.bars.loadItems();
            foo.bars.set(await Promise.all(barsInput.map(async (barInput) => {
                const { bazs: bazsInput, ...assignInput } = barInput;
                return this.entityManager.assign(new Bar(), {
                    ...assignInput,
                });
                if (bazsInput) {
                    await bar.bazs.loadItems();
                    bar.bazs.set(bazsInput.map((bazInput) => {
                        return this.entityManager.assign(new Baz(), {
                            ...bazInput,
                        });
                    }));
                }
            })));
        }
        await this.entityManager.flush();
        return foo;
    }
    @Mutation(() => Foo)
    @AffectedEntity(Foo)
    async updateFoo(
    @Args("id", { type: () => ID })
    id: string, 
    @Args("input", { type: () => FooUpdateInput })
    input: FooUpdateInput): Promise<Foo> {
        const foo = await this.entityManager.findOneOrFail(Foo, id);
        const { bars: barsInput, ...assignInput } = input;
        foo.assign({
            ...assignInput,
        });
        if (barsInput) {
            await foo.bars.loadItems();
            foo.bars.set(await Promise.all(barsInput.map(async (barInput) => {
                const { bazs: bazsInput, ...assignInput } = barInput;
                return this.entityManager.assign(new Bar(), {
                    ...assignInput,
                });
                if (bazsInput) {
                    await bar.bazs.loadItems();
                    bar.bazs.set(bazsInput.map((bazInput) => {
                        return this.entityManager.assign(new Baz(), {
                            ...bazInput,
                        });
                    }));
                }
            })));
        }
        await this.entityManager.flush();
        return foo;
    }
    @Mutation(() => Boolean)
    @AffectedEntity(Foo)
    async deleteFoo(
    @Args("id", { type: () => ID })
    id: string): Promise<boolean> {
        const foo = await this.entityManager.findOneOrFail(Foo, id);
        this.entityManager.remove(foo);
        await this.entityManager.flush();
        return true;
    }
    @ResolveField(() => [Bar])
    async bars(
    @Parent()
    foo: Foo): Promise<Bar[]> {
        return foo.bars.loadItems();
    }
}
