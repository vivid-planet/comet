// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { AffectedEntity, extractGraphqlFields, RequiredPermission, validateNotModified } from "@comet/cms-api";
import { FindOptions, Reference } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Parent, Query, ResolveField, Resolver } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";

import { Product } from "../entities/product.entity";
import { ProductVariant } from "../entities/product-variant.entity";
import { PaginatedProductVariants } from "./dto/paginated-product-variants";
import { ProductVariantInput, ProductVariantUpdateInput } from "./dto/product-variant.input";
import { ProductVariantsArgs } from "./dto/product-variants.args";
import { ProductVariantsService } from "./product-variants.service";

@Resolver(() => ProductVariant)
@RequiredPermission("products", { skipScopeCheck: true })
export class ProductVariantResolver {
    constructor(
        private readonly entityManager: EntityManager,
        private readonly productVariantsService: ProductVariantsService,
        @InjectRepository(ProductVariant) private readonly repository: EntityRepository<ProductVariant>,
        @InjectRepository(Product) private readonly productRepository: EntityRepository<Product>,
    ) {}

    @Query(() => ProductVariant)
    @AffectedEntity(ProductVariant)
    async productVariant(@Args("id", { type: () => ID }) id: string): Promise<ProductVariant> {
        const productVariant = await this.repository.findOneOrFail(id);
        return productVariant;
    }

    @Query(() => PaginatedProductVariants)
    @AffectedEntity(Product, { idArg: "product" })
    async productVariants(
        @Args() { product, search, filter, sort, offset, limit }: ProductVariantsArgs,
        @Info() info: GraphQLResolveInfo,
    ): Promise<PaginatedProductVariants> {
        const where = this.productVariantsService.getFindCondition({ search, filter });

        where.product = product;

        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("product")) {
            populate.push("product");
        }

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<ProductVariant, any> = { offset, limit, populate };

        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedProductVariants(entities, totalCount);
    }

    @Mutation(() => ProductVariant)
    @AffectedEntity(Product, { idArg: "product" })
    async createProductVariant(
        @Args("product", { type: () => ID }) product: string,
        @Args("input", { type: () => ProductVariantInput }) input: ProductVariantInput,
    ): Promise<ProductVariant> {
        const { image: imageInput, ...assignInput } = input;
        const productVariant = this.repository.create({
            ...assignInput,

            product: Reference.create(await this.productRepository.findOneOrFail(product)),

            image: imageInput.transformToBlockData(),
        });

        await this.entityManager.flush();

        return productVariant;
    }

    @Mutation(() => ProductVariant)
    @AffectedEntity(ProductVariant)
    async updateProductVariant(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => ProductVariantUpdateInput }) input: ProductVariantUpdateInput,
        @Args("lastUpdatedAt", { type: () => Date, nullable: true }) lastUpdatedAt?: Date,
    ): Promise<ProductVariant> {
        const productVariant = await this.repository.findOneOrFail(id);
        if (lastUpdatedAt) {
            validateNotModified(productVariant, lastUpdatedAt);
        }

        const { image: imageInput, ...assignInput } = input;
        productVariant.assign({
            ...assignInput,
        });

        if (imageInput) {
            productVariant.image = imageInput.transformToBlockData();
        }

        await this.entityManager.flush();

        return productVariant;
    }

    @Mutation(() => Boolean)
    @AffectedEntity(ProductVariant)
    async deleteProductVariant(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const productVariant = await this.repository.findOneOrFail(id);
        await this.entityManager.remove(productVariant);
        await this.entityManager.flush();
        return true;
    }

    @ResolveField(() => Product)
    async product(@Parent() productVariant: ProductVariant): Promise<Product> {
        return productVariant.product.load();
    }
}
