// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { EntityManager, FindOptions, Reference } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Query, Resolver, ResolveField, Parent } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";
import { ProductVariantsService } from "./product-variants.service";
import { ProductVariantInput, ProductVariantUpdateInput } from "./dto/product-variant.input";
import { PaginatedProductVariants } from "./dto/paginated-product-variants";
import { ProductVariantsArgs } from "./dto/product-variants.args";
import { Product } from "../entities/product.entity";
import { AffectedEntity, BlocksTransformerService, DamImageBlock, RequiredPermission, RootBlockDataScalar, extractGraphqlFields, gqlArgsToMikroOrmQuery } from "@comet/cms-api";
import { ProductVariant } from "../entities/product-variant.entity";
@Resolver(() => ProductVariant)
@RequiredPermission("products", { skipScopeCheck: true })
export class ProductVariantResolver {
    constructor(private readonly entityManager: EntityManager, private readonly productVariantsService: ProductVariantsService, private readonly blocksTransformer: BlocksTransformerService) { }
    @Query(() => ProductVariant)
    @AffectedEntity(ProductVariant)
    async productVariant(
    @Args("id", { type: () => ID })
    id: string): Promise<ProductVariant> {
        const productVariant = await this.entityManager.findOneOrFail(ProductVariant, id);
        return productVariant;
    }
    @Query(() => PaginatedProductVariants)
    @AffectedEntity(Product, { idArg: "product" })
    async productVariants(
    @Args()
    { product, search, filter, sort, offset, limit }: ProductVariantsArgs, 
    @Info()
    info: GraphQLResolveInfo): Promise<PaginatedProductVariants> {
        const where = gqlArgsToMikroOrmQuery({ search, filter, }, this.entityManager.getMetadata(ProductVariant));
        where.product = product;
        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("product")) {
            populate.push("product");
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<ProductVariant, any> = { offset, limit, populate };
        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }
        const [entities, totalCount] = await this.entityManager.findAndCount(ProductVariant, where, options);
        return new PaginatedProductVariants(entities, totalCount);
    }
    @Mutation(() => ProductVariant)
    @AffectedEntity(Product, { idArg: "product" })
    async createProductVariant(
    @Args("product", { type: () => ID })
    product: string, 
    @Args("input", { type: () => ProductVariantInput })
    input: ProductVariantInput): Promise<ProductVariant> {
        const lastPosition = await this.productVariantsService.getLastPosition({ product });
        let position = input.position;
        if (position !== undefined && position < lastPosition + 1) {
            await this.productVariantsService.incrementPositions({ product }, position);
        }
        else {
            position = lastPosition + 1;
        }
        const { image: imageInput, ...assignInput } = input;
        const productVariant = this.entityManager.create(ProductVariant, {
            ...assignInput,
            position,
            product: Reference.create(await this.entityManager.findOneOrFail(Product, product)),
            image: imageInput.transformToBlockData(),
        });
        await this.entityManager.flush();
        return productVariant;
    }
    @Mutation(() => ProductVariant)
    @AffectedEntity(ProductVariant)
    async updateProductVariant(
    @Args("id", { type: () => ID })
    id: string, 
    @Args("input", { type: () => ProductVariantUpdateInput })
    input: ProductVariantUpdateInput): Promise<ProductVariant> {
        const productVariant = await this.entityManager.findOneOrFail(ProductVariant, id);
        if (input.position !== undefined) {
            const lastPosition = await this.productVariantsService.getLastPosition({ product: productVariant.product.id });
            if (input.position > lastPosition + 1) {
                input.position = lastPosition + 1;
            }
            if (productVariant.position < input.position) {
                await this.productVariantsService.decrementPositions({ product: productVariant.product.id }, productVariant.position, input.position);
            }
            else if (productVariant.position > input.position) {
                await this.productVariantsService.incrementPositions({ product: productVariant.product.id }, input.position, productVariant.position);
            }
        }
        const { image: imageInput, ...assignInput } = input;
        productVariant.assign({
            ...assignInput,
        });
        if (imageInput) {
            productVariant.image = imageInput.transformToBlockData();
        }
        await this.entityManager.flush();
        return productVariant;
    }
    @Mutation(() => Boolean)
    @AffectedEntity(ProductVariant)
    async deleteProductVariant(
    @Args("id", { type: () => ID })
    id: string): Promise<boolean> {
        const productVariant = await this.entityManager.findOneOrFail(ProductVariant, id);
        this.entityManager.remove(productVariant);
        await this.productVariantsService.decrementPositions({ product: productVariant.product.id }, productVariant.position);
        await this.entityManager.flush();
        return true;
    }
    @ResolveField(() => Product)
    async product(
    @Parent()
    productVariant: ProductVariant): Promise<Product> {
        return productVariant.product.loadOrFail();
    }
    @ResolveField(() => RootBlockDataScalar(DamImageBlock))
    async image(
    @Parent()
    productVariant: ProductVariant): Promise<object> {
        return this.blocksTransformer.transformToPlain(productVariant.image);
    }
}
