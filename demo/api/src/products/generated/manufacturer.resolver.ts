// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { EntityManager, FindOptions } from "@mikro-orm/postgresql";
import { Args, ID, Mutation, Query, Resolver } from "@nestjs/graphql";
import { ManufacturerInput, ManufacturerUpdateInput } from "./dto/manufacturer.input";
import { PaginatedManufacturers } from "./dto/paginated-manufacturers";
import { ManufacturersArgs } from "./dto/manufacturers.args";
import { Manufacturer } from "../entities/manufacturer.entity";
import { AffectedEntity, RequiredPermission, gqlArgsToMikroOrmQuery } from "@comet/cms-api";
@Resolver(() => Manufacturer)
@RequiredPermission(["manufacturers"], { skipScopeCheck: true })
export class ManufacturerResolver {
    constructor(private readonly entityManager: EntityManager) { }
    @Query(() => Manufacturer)
    @AffectedEntity(Manufacturer)
    async manufacturer(
    @Args("id", { type: () => ID })
    id: string): Promise<Manufacturer> {
        const manufacturer = await this.entityManager.findOneOrFail(Manufacturer, id);
        return manufacturer;
    }
    @Query(() => PaginatedManufacturers)
    async manufacturers(
    @Args()
    { search, filter, sort, offset, limit }: ManufacturersArgs): Promise<PaginatedManufacturers> {
        const where = gqlArgsToMikroOrmQuery({ search, filter, }, this.entityManager.getMetadata(Manufacturer));
        const options: FindOptions<Manufacturer> = { offset, limit };
        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }
        const [entities, totalCount] = await this.entityManager.findAndCount(Manufacturer, where, options);
        return new PaginatedManufacturers(entities, totalCount);
    }
    @Mutation(() => Manufacturer)
    async createManufacturer(
    @Args("input", { type: () => ManufacturerInput })
    input: ManufacturerInput): Promise<Manufacturer> {
        const manufacturer = this.entityManager.create(Manufacturer, {
            ...input,
        });
        await this.entityManager.flush();
        return manufacturer;
    }
    @Mutation(() => Manufacturer)
    @AffectedEntity(Manufacturer)
    async updateManufacturer(
    @Args("id", { type: () => ID })
    id: string, 
    @Args("input", { type: () => ManufacturerUpdateInput })
    input: ManufacturerUpdateInput): Promise<Manufacturer> {
        const manufacturer = await this.entityManager.findOneOrFail(Manufacturer, id);
        manufacturer.assign({
            ...input,
        });
        await this.entityManager.flush();
        return manufacturer;
    }
    @Mutation(() => Boolean)
    @AffectedEntity(Manufacturer)
    async deleteManufacturer(
    @Args("id", { type: () => ID })
    id: string): Promise<boolean> {
        const manufacturer = await this.entityManager.findOneOrFail(Manufacturer, id);
        this.entityManager.remove(manufacturer);
        await this.entityManager.flush();
        return true;
    }
}
