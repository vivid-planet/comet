// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { EntityManager, FindOptions, Reference } from "@mikro-orm/postgresql";
import { Args, ID, Mutation, Query, Resolver, ResolveField, Parent } from "@nestjs/graphql";
import { ProductCategoriesService } from "./product-categories.service";
import { ProductCategoryInput, ProductCategoryUpdateInput } from "./dto/product-category.input";
import { PaginatedProductCategories } from "./dto/paginated-product-categories";
import { ProductCategoriesArgs } from "./dto/product-categories.args";
import { ProductCategoryType } from "../entities/product-category-type.entity";
import { Product } from "../entities/product.entity";
import { ProductCategory } from "../entities/product-category.entity";
import { AffectedEntity, RequiredPermission, gqlArgsToMikroOrmQuery, gqlSortToMikroOrmOrderBy } from "@comet/cms-api";
@Resolver(() => ProductCategory)
@RequiredPermission(["products"], { skipScopeCheck: true })
export class ProductCategoryResolver {
    constructor(
        protected readonly entityManager: EntityManager,
        protected readonly productCategoriesService: ProductCategoriesService,
    ) {}
    @Query(() => ProductCategory)
    @AffectedEntity(ProductCategory)
    async productCategory(
        @Args("id", { type: () => ID })
        id: string,
    ): Promise<ProductCategory> {
        const productCategory = await this.entityManager.findOneOrFail(ProductCategory, id);
        return productCategory;
    }
    @Query(() => ProductCategory, { nullable: true })
    async productCategoryBySlug(
        @Args("slug")
        slug: string,
    ): Promise<ProductCategory | null> {
        const productCategory = await this.entityManager.findOne(ProductCategory, { slug });
        return productCategory ?? null;
    }
    @Query(() => PaginatedProductCategories)
    async productCategories(
        @Args()
        { search, filter, sort, offset, limit }: ProductCategoriesArgs,
    ): Promise<PaginatedProductCategories> {
        const where = gqlArgsToMikroOrmQuery({ search, filter }, this.entityManager.getMetadata(ProductCategory));
        const options: FindOptions<ProductCategory> = { offset, limit };
        if (sort) {
            options.orderBy = gqlSortToMikroOrmOrderBy(sort);
        }
        const [entities, totalCount] = await this.entityManager.findAndCount(ProductCategory, where, options);
        return new PaginatedProductCategories(entities, totalCount);
    }
    @Mutation(() => ProductCategory)
    async createProductCategory(
        @Args("input", { type: () => ProductCategoryInput })
        input: ProductCategoryInput,
    ): Promise<ProductCategory> {
        const lastPosition = await this.productCategoriesService.getLastPosition();
        let position = input.position;
        if (position !== undefined && position < lastPosition + 1) {
            await this.productCategoriesService.incrementPositions(position);
        } else {
            position = lastPosition + 1;
        }
        const { products: productsInput, type: typeInput, ...assignInput } = input;
        const productCategory = this.entityManager.create(ProductCategory, {
            ...assignInput,
            position,
            type: typeInput ? Reference.create(await this.entityManager.findOneOrFail(ProductCategoryType, typeInput)) : undefined,
        });
        if (productsInput) {
            const products = await this.entityManager.find(Product, { id: productsInput });
            if (products.length != productsInput.length) throw new Error("Couldn't find all products that were passed as input");
            await productCategory.products.loadItems();
            productCategory.products.set(products.map((product) => Reference.create(product)));
        }
        await this.entityManager.flush();
        return productCategory;
    }
    @Mutation(() => ProductCategory)
    @AffectedEntity(ProductCategory)
    async updateProductCategory(
        @Args("id", { type: () => ID })
        id: string,
        @Args("input", { type: () => ProductCategoryUpdateInput })
        input: ProductCategoryUpdateInput,
    ): Promise<ProductCategory> {
        const productCategory = await this.entityManager.findOneOrFail(ProductCategory, id);
        if (input.position !== undefined) {
            const lastPosition = await this.productCategoriesService.getLastPosition();
            if (input.position > lastPosition) {
                input.position = lastPosition;
            }
            if (productCategory.position < input.position) {
                await this.productCategoriesService.decrementPositions(productCategory.position, input.position);
            } else if (productCategory.position > input.position) {
                await this.productCategoriesService.incrementPositions(input.position, productCategory.position);
            }
        }
        const { products: productsInput, type: typeInput, ...assignInput } = input;
        productCategory.assign({
            ...assignInput,
        });
        if (productsInput) {
            const products = await this.entityManager.find(Product, { id: productsInput });
            if (products.length != productsInput.length) throw new Error("Couldn't find all products that were passed as input");
            await productCategory.products.loadItems();
            productCategory.products.set(products.map((product) => Reference.create(product)));
        }
        if (typeInput !== undefined) {
            productCategory.type = typeInput ? Reference.create(await this.entityManager.findOneOrFail(ProductCategoryType, typeInput)) : undefined;
        }
        await this.entityManager.flush();
        return productCategory;
    }
    @Mutation(() => Boolean)
    @AffectedEntity(ProductCategory)
    async deleteProductCategory(
        @Args("id", { type: () => ID })
        id: string,
    ): Promise<boolean> {
        const productCategory = await this.entityManager.findOneOrFail(ProductCategory, id);
        this.entityManager.remove(productCategory);
        await this.productCategoriesService.decrementPositions(productCategory.position);
        await this.entityManager.flush();
        return true;
    }
    @ResolveField(() => ProductCategoryType, { nullable: true })
    async type(
        @Parent()
        productCategory: ProductCategory,
    ): Promise<ProductCategoryType | undefined> {
        return productCategory.type?.loadOrFail();
    }
    @ResolveField(() => [Product])
    async products(
        @Parent()
        productCategory: ProductCategory,
    ): Promise<Product[]> {
        return productCategory.products.loadItems();
    }
}
