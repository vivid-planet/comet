// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { AffectedEntity, extractGraphqlFields, RequiredPermission } from "@comet/cms-api";
import { FindOptions } from "@mikro-orm/core";
import { InjectRepository } from "@mikro-orm/nestjs";
import { EntityManager, EntityRepository } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Parent, Query, ResolveField, Resolver } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";

import { Product } from "../entities/product.entity";
import { ProductCategory } from "../entities/product-category.entity";
import { PaginatedProductCategories } from "./dto/paginated-product-categories";
import { ProductCategoriesArgs } from "./dto/product-categories.args";
import { ProductCategoryInput, ProductCategoryUpdateInput } from "./dto/product-category.input";
import { ProductCategoriesService } from "./product-categories.service";

@Resolver(() => ProductCategory)
@RequiredPermission(["products"], { skipScopeCheck: true })
export class ProductCategoryResolver {
    constructor(
        private readonly entityManager: EntityManager,
        private readonly productCategoriesService: ProductCategoriesService,
        @InjectRepository(ProductCategory) private readonly repository: EntityRepository<ProductCategory>,
    ) {}

    @Query(() => ProductCategory)
    @AffectedEntity(ProductCategory)
    async productCategory(@Args("id", { type: () => ID }) id: string): Promise<ProductCategory> {
        const productCategory = await this.repository.findOneOrFail(id);
        return productCategory;
    }

    @Query(() => ProductCategory, { nullable: true })
    async productCategoryBySlug(@Args("slug") slug: string): Promise<ProductCategory | null> {
        const productCategory = await this.repository.findOne({ slug });

        return productCategory ?? null;
    }

    @Query(() => PaginatedProductCategories)
    async productCategories(
        @Args() { search, filter, sort, offset, limit }: ProductCategoriesArgs,
        @Info() info: GraphQLResolveInfo,
    ): Promise<PaginatedProductCategories> {
        const where = this.productCategoriesService.getFindCondition({ search, filter });

        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("products")) {
            populate.push("products");
        }

        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<ProductCategory, any> = { offset, limit, populate };

        if (sort) {
            options.orderBy = sort.map((sortItem) => {
                return {
                    [sortItem.field]: sortItem.direction,
                };
            });
        }

        const [entities, totalCount] = await this.repository.findAndCount(where, options);
        return new PaginatedProductCategories(entities, totalCount);
    }

    @Mutation(() => ProductCategory)
    async createProductCategory(@Args("input", { type: () => ProductCategoryInput }) input: ProductCategoryInput): Promise<ProductCategory> {
        const lastPosition = await this.getLastPosition();
        if (input.position !== undefined && input.position < lastPosition + 1) {
            await this.incrementPositions(input.position);
        } else {
            input.position = lastPosition + 1;
        }

        const productCategory = this.repository.create({
            ...input,
        });

        await this.entityManager.flush();

        return productCategory;
    }

    @Mutation(() => ProductCategory)
    @AffectedEntity(ProductCategory)
    async updateProductCategory(
        @Args("id", { type: () => ID }) id: string,
        @Args("input", { type: () => ProductCategoryUpdateInput }) input: ProductCategoryUpdateInput,
    ): Promise<ProductCategory> {
        const productCategory = await this.repository.findOneOrFail(id);

        if (input.position !== undefined) {
            const lastPosition = await this.getLastPosition();
            if (input.position > lastPosition + 1) {
                input.position = lastPosition + 1;
            }
            if (productCategory.position < input.position) {
                await this.decrementPositions(productCategory.position, input.position);
            } else if (productCategory.position > input.position) {
                await this.incrementPositions(input.position, productCategory.position);
            }
        }

        productCategory.assign({
            ...input,
        });

        await this.entityManager.flush();

        return productCategory;
    }

    @Mutation(() => Boolean)
    @AffectedEntity(ProductCategory)
    async deleteProductCategory(@Args("id", { type: () => ID }) id: string): Promise<boolean> {
        const productCategory = await this.repository.findOneOrFail(id);
        this.entityManager.remove(productCategory);
        await this.decrementPositions(productCategory.position);
        await this.entityManager.flush();
        return true;
    }

    @ResolveField(() => [Product])
    async products(@Parent() productCategory: ProductCategory): Promise<Product[]> {
        return productCategory.products.loadItems();
    }

    async incrementPositions(lowestPosition: number, highestPosition?: number) {
        // Increment positions between newPosition (inclusive) and oldPosition (exclusive)
        await this.repository.nativeUpdate(
            { position: { $gte: lowestPosition, $lt: highestPosition } }, // add filter for grouping if necessary
            { position: this.entityManager.raw("position + 1") },
        );
    }

    async decrementPositions(lowestPosition: number, highestPosition?: number) {
        // Decrement positions between oldPosition (exclusive) and newPosition (inclusive)
        await this.repository.nativeUpdate(
            { position: { $gt: lowestPosition, $lte: highestPosition } }, // add filter for grouping if necessary
            { position: this.entityManager.raw("position - 1") },
        );
    }

    async getLastPosition() {
        return this.repository.count({}); // add filter for grouping if necessary
    }
}
