// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { EntityManager, FindOptions, ObjectQuery, Reference } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Query, Resolver, ResolveField, Parent } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";
import { ProductHighlightInput, ProductHighlightUpdateInput } from "./dto/product-highlight.input";
import { Product } from "../entities/product.entity";
import { ProductHighlight } from "../entities/product-highlight.entity";
import { AffectedEntity, RequiredPermission, extractGraphqlFields } from "@comet/cms-api";
@Resolver(() => ProductHighlight)
@RequiredPermission(["products"], { skipScopeCheck: true })
export class ProductHighlightResolver {
    constructor(protected readonly entityManager: EntityManager) {}
    @Query(() => ProductHighlight)
    @AffectedEntity(ProductHighlight)
    async productHighlight(
        @Args("id", { type: () => ID })
        id: string,
    ): Promise<ProductHighlight> {
        const productHighlight = await this.entityManager.findOneOrFail(ProductHighlight, id);
        return productHighlight;
    }
    @Query(() => [ProductHighlight])
    async productHighlights(
        @Info()
        info: GraphQLResolveInfo,
    ): Promise<ProductHighlight[]> {
        const where: ObjectQuery<ProductHighlight> = {};
        const fields = extractGraphqlFields(info);
        const populate: string[] = [];
        if (fields.includes("product")) {
            populate.push("product");
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<ProductHighlight, any> = { populate };
        const entities = await this.entityManager.find(ProductHighlight, where, options);
        return entities;
    }
    @Mutation(() => ProductHighlight)
    async createProductHighlight(
        @Args("input", { type: () => ProductHighlightInput })
        input: ProductHighlightInput,
    ): Promise<ProductHighlight> {
        const { product: productInput, ...assignInput } = input;
        const productHighlight = this.entityManager.create(ProductHighlight, {
            ...assignInput,
            product: Reference.create(await this.entityManager.findOneOrFail(Product, productInput)),
        });
        await this.entityManager.flush();
        return productHighlight;
    }
    @Mutation(() => ProductHighlight)
    @AffectedEntity(ProductHighlight)
    async updateProductHighlight(
        @Args("id", { type: () => ID })
        id: string,
        @Args("input", { type: () => ProductHighlightUpdateInput })
        input: ProductHighlightUpdateInput,
    ): Promise<ProductHighlight> {
        const productHighlight = await this.entityManager.findOneOrFail(ProductHighlight, id);
        const { product: productInput, ...assignInput } = input;
        productHighlight.assign({
            ...assignInput,
        });
        if (productInput !== undefined) {
            productHighlight.product = Reference.create(await this.entityManager.findOneOrFail(Product, productInput));
        }
        await this.entityManager.flush();
        return productHighlight;
    }
    @Mutation(() => Boolean)
    @AffectedEntity(ProductHighlight)
    async deleteProductHighlight(
        @Args("id", { type: () => ID })
        id: string,
    ): Promise<boolean> {
        const productHighlight = await this.entityManager.findOneOrFail(ProductHighlight, id);
        this.entityManager.remove(productHighlight);
        await this.entityManager.flush();
        return true;
    }
    @ResolveField(() => Product)
    async product(
        @Parent()
        productHighlight: ProductHighlight,
    ): Promise<Product> {
        return productHighlight.product.loadOrFail();
    }
}
