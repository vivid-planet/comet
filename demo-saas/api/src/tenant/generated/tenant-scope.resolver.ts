// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { EntityManager, FindOptions, Reference } from "@mikro-orm/postgresql";
import { Args, ID, Info, Mutation, Query, Resolver, ResolveField, Parent } from "@nestjs/graphql";
import { GraphQLResolveInfo } from "graphql";
import { TenantScopeInput, TenantScopeUpdateInput } from "./dto/tenant-scope.input";
import { PaginatedTenantScopes } from "./dto/paginated-tenant-scopes";
import { TenantScopesArgs } from "./dto/tenant-scopes.args";
import { Tenant } from "../entities/tenant.entity";
import { TenantScope } from "../entities/tenant-scope.entity";
import { AffectedEntity, RequiredPermission, extractGraphqlFields, gqlArgsToMikroOrmQuery, gqlSortToMikroOrmOrderBy } from "@comet/cms-api";
@Resolver(() => TenantScope)
@RequiredPermission(["tenantAdministration"], { skipScopeCheck: true })
export class TenantScopeResolver {
    constructor(protected readonly entityManager: EntityManager) { }
    @Query(() => TenantScope)
    @AffectedEntity(TenantScope)
    async tenantScope(
    @Args("id", { type: () => ID })
    id: string): Promise<TenantScope> {
        const tenantScope = await this.entityManager.findOneOrFail(TenantScope, id);
        return tenantScope;
    }
    @Query(() => PaginatedTenantScopes)
    @AffectedEntity(Tenant, { idArg: "tenant" })
    async tenantScopes(
    @Args()
    { tenant, search, filter, sort, offset, limit }: TenantScopesArgs, 
    @Info()
    info: GraphQLResolveInfo): Promise<PaginatedTenantScopes> {
        const where = gqlArgsToMikroOrmQuery({ search, filter, }, this.entityManager.getMetadata(TenantScope));
        where.tenant = tenant;
        const fields = extractGraphqlFields(info, { root: "nodes" });
        const populate: string[] = [];
        if (fields.includes("tenant")) {
            populate.push("tenant");
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const options: FindOptions<TenantScope, any> = { offset, limit, populate };
        if (sort) {
            options.orderBy = gqlSortToMikroOrmOrderBy(sort);
        }
        const [entities, totalCount] = await this.entityManager.findAndCount(TenantScope, where, options);
        return new PaginatedTenantScopes(entities, totalCount);
    }
    @Mutation(() => TenantScope)
    @AffectedEntity(Tenant, { idArg: "tenant" })
    async createTenantScope(
    @Args("tenant", { type: () => ID })
    tenant: string, 
    @Args("input", { type: () => TenantScopeInput })
    input: TenantScopeInput): Promise<TenantScope> {
        const tenantScope = this.entityManager.create(TenantScope, {
            ...input,
            tenant: Reference.create(await this.entityManager.findOneOrFail(Tenant, tenant)),
        });
        await this.entityManager.flush();
        return tenantScope;
    }
    @Mutation(() => TenantScope)
    @AffectedEntity(TenantScope)
    async updateTenantScope(
    @Args("id", { type: () => ID })
    id: string, 
    @Args("input", { type: () => TenantScopeUpdateInput })
    input: TenantScopeUpdateInput): Promise<TenantScope> {
        const tenantScope = await this.entityManager.findOneOrFail(TenantScope, id);
        tenantScope.assign({
            ...input,
        });
        await this.entityManager.flush();
        return tenantScope;
    }
    @ResolveField(() => Tenant)
    async tenant(
    @Parent()
    tenantScope: TenantScope): Promise<Tenant> {
        return tenantScope.tenant.loadOrFail();
    }
}
