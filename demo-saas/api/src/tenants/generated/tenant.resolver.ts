// This file has been generated by comet api-generator.
// You may choose to use this file as scaffold by moving this file out of generated folder and removing this comment.
import { EntityManager, FindOptions } from "@mikro-orm/postgresql";
import { Args, ID, Mutation, Query, Resolver } from "@nestjs/graphql";
import { TenantInput, TenantUpdateInput } from "./dto/tenant.input";
import { PaginatedTenants } from "./dto/paginated-tenants";
import { TenantsArgs } from "./dto/tenants.args";
import { Tenant } from "../entities/tenant.entity";
import { AffectedEntity, RequiredPermission, gqlArgsToMikroOrmQuery, gqlSortToMikroOrmOrderBy } from "@comet/cms-api";
@Resolver(() => Tenant)
@RequiredPermission(["tenants"], { skipScopeCheck: true })
export class TenantResolver {
    constructor(protected readonly entityManager: EntityManager) { }
    @Query(() => Tenant)
    @AffectedEntity(Tenant)
    async tenant(
    @Args("id", { type: () => ID })
    id: string): Promise<Tenant> {
        const tenant = await this.entityManager.findOneOrFail(Tenant, id);
        return tenant;
    }
    @Query(() => PaginatedTenants)
    async tenants(
    @Args()
    { search, filter, sort, offset, limit }: TenantsArgs): Promise<PaginatedTenants> {
        const where = gqlArgsToMikroOrmQuery({ search, filter, }, this.entityManager.getMetadata(Tenant));
        const options: FindOptions<Tenant> = { offset, limit };
        if (sort) {
            options.orderBy = gqlSortToMikroOrmOrderBy(sort);
        }
        const [entities, totalCount] = await this.entityManager.findAndCount(Tenant, where, options);
        return new PaginatedTenants(entities, totalCount);
    }
    @Mutation(() => Tenant)
    async createTenant(
    @Args("input", { type: () => TenantInput })
    input: TenantInput): Promise<Tenant> {
        const tenant = this.entityManager.create(Tenant, {
            ...input,
        });
        await this.entityManager.flush();
        return tenant;
    }
    @Mutation(() => Tenant)
    @AffectedEntity(Tenant)
    async updateTenant(
    @Args("id", { type: () => ID })
    id: string, 
    @Args("input", { type: () => TenantUpdateInput })
    input: TenantUpdateInput): Promise<Tenant> {
        const tenant = await this.entityManager.findOneOrFail(Tenant, id);
        tenant.assign({
            ...input,
        });
        await this.entityManager.flush();
        return tenant;
    }
    @Mutation(() => Boolean)
    @AffectedEntity(Tenant)
    async deleteTenant(
    @Args("id", { type: () => ID })
    id: string): Promise<boolean> {
        const tenant = await this.entityManager.findOneOrFail(Tenant, id);
        this.entityManager.remove(tenant);
        await this.entityManager.flush();
        return true;
    }
}
