# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Address {
  alternativeAddress: AlternativeAddress
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

type AddressAsEmbeddable {
  alternativeAddress: AlternativeAddressAsEmbeddable!
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

input AddressAsEmbeddableInput {
  alternativeAddress: AlternativeAddressAsEmbeddableInput!
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

input AddressInput {
  alternativeAddress: AlternativeAddressInput
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

type AlternativeAddress {
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

type AlternativeAddressAsEmbeddable {
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

input AlternativeAddressAsEmbeddableInput {
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

input AlternativeAddressInput {
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

type AutoBuildStatus {
  hasChangesSinceLastBuild: Boolean!
  lastCheck: DateTime
  nextCheck: DateTime!
}

input BooleanFilter {
  equal: Boolean
}

type Build {
  completionTime: DateTime
  estimatedCompletionTime: DateTime
  id: ID!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  name: String
  startTime: DateTime
  status: KubernetesJobStatus!
  trigger: String
}

type BuildTemplate {
  id: ID!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  name: String!
}

type ContentScopeWithLabel {
  label: JSONObject!
  scope: JSONObject!
}

type Coordinates {
  latitude: Float!
  longitude: Float!
}

input CoordinatesInput {
  latitude: Float!
  longitude: Float!
}

type CopyFilesResponse {
  mappedFiles: [MappedFile!]!
}

input CreateBuildsInput {
  names: [String!]!
}

input CreateDamFolderInput {
  isInboxFromOtherScope: Boolean! = false
  name: String!
  parentId: ID
}

type CurrentUser {
  allowedContentScopes: [ContentScopeWithLabel!]!
  authenticatedUser: UserPermissionsUser
  email: String!
  id: String!
  impersonated: Boolean
  name: String!
  permissions: [CurrentUserPermission!]!
  permissionsForScope(scope: JSONObject!): [String!]!
}

type CurrentUserPermission {
  contentScopes: [JSONObject!]!
  permission: Permission!
}

type DamFile {
  altText: String
  alternativesForThisFile: [DamMediaAlternative!]!
  archived: Boolean!
  contentHash: String!
  createdAt: DateTime!
  damPath: String!
  dependents(filter: DependentFilter, forceRefresh: Boolean! = false, limit: Int! = 25, offset: Int! = 0): PaginatedDependencies!
  duplicates: [DamFile!]!
  fileUrl: String!
  folder: DamFolder
  id: ID!
  image: DamFileImage
  importSourceId: String
  importSourceType: String
  license: DamFileLicense
  mimetype: String!
  name: String!
  scope: DamScope!
  size: Int!
  thisFileIsAlternativeFor: [DamMediaAlternative!]!
  title: String
  updatedAt: DateTime!
}

type DamFileImage {
  cropArea: ImageCropArea!
  dominantColor: String
  exif: JSONObject
  height: Int!
  id: ID!
  url(height: Int!, width: Int!): String
  width: Int!
}

type DamFileLicense {
  author: String
  details: String
  durationFrom: DateTime
  durationTo: DateTime

  """The expirationDate is the durationTo + 1 day"""
  expirationDate: DateTime
  expiresWithinThirtyDays: Boolean!
  hasExpired: Boolean!
  isNotValidYet: Boolean!
  isValid: Boolean!
  type: LicenseType
}

type DamFolder {
  archived: Boolean!
  createdAt: DateTime!
  id: ID!
  isInboxFromOtherScope: Boolean!
  mpath: [ID!]!
  name: String!
  numberOfChildFolders: Int!
  numberOfFiles: Int!
  parent: DamFolder
  parents: [DamFolder!]!
  scope: DamScope!
  updatedAt: DateTime!
}

"""DamImage root block data"""
scalar DamImageBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""DamImage root block input"""
scalar DamImageBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

union DamItem = DamFile | DamFolder

input DamItemFilterInput {
  mimetypes: [String!]
  searchText: String
}

enum DamItemType {
  File
  Folder
}

type DamMediaAlternative {
  alternative: DamFile!
  for: DamFile!
  id: ID!
  language: String!
  type: DamMediaAlternativeType!
}

input DamMediaAlternativeInput {
  language: String!
  type: DamMediaAlternativeType!
}

input DamMediaAlternativeSort {
  direction: SortDirection! = ASC
  field: DamMediaAlternativeSortField!
}

enum DamMediaAlternativeSortField {
  alternative
  for
  id
  language
  type
}

enum DamMediaAlternativeType {
  captions
}

input DamMediaAlternativeUpdateInput {
  alternative: ID
  for: ID
  language: String
  type: DamMediaAlternativeType
}

type DamScope {
  domain: String!
}

input DamScopeInput {
  domain: String!
}

input DateFilter {
  equal: LocalDate
  greaterThan: LocalDate
  greaterThanEqual: LocalDate
  isEmpty: Boolean
  isNotEmpty: Boolean
  lowerThan: LocalDate
  lowerThanEqual: LocalDate
  notEqual: LocalDate
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equal: DateTime
  greaterThan: DateTime
  greaterThanEqual: DateTime
  isEmpty: Boolean
  isNotEmpty: Boolean
  lowerThan: DateTime
  lowerThanEqual: DateTime
  notEqual: DateTime
}

type Dependency {
  jsonPath: String!
  name: String
  rootColumnName: String!
  rootGraphqlObjectType: String!
  rootId: String!
  secondaryInformation: String
  targetGraphqlObjectType: String!
  targetId: String!
  visible: Boolean!
}

input DependencyFilter {
  rootColumnName: String
  targetGraphqlObjectType: String
  targetId: String
}

input DependentFilter {
  rootColumnName: String
  rootGraphqlObjectType: String
  rootId: String
}

interface DocumentInterface {
  id: ID!
  updatedAt: DateTime!
}

type EntityInfo {
  name: String!
  secondaryInformation: String
}

input FileFilterInput {
  mimetypes: [String!]
  searchText: String
}

type FileUpload {
  contentHash: String!
  createdAt: DateTime!
  downloadUrl: String!
  id: ID!
  imageUrl(resizeWidth: Int!): String
  mimetype: String!
  name: String!
  previewUrl: String!
  size: Int!
  updatedAt: DateTime!
}

input FilenameInput {
  folderId: ID
  name: String!
}

type FilenameResponse {
  folderId: ID
  isOccupied: Boolean!
  name: String!
}

enum FocalPoint {
  CENTER
  NORTHEAST
  NORTHWEST
  SMART
  SOUTHEAST
  SOUTHWEST
}

input FolderFilterInput {
  searchText: String
}

input IdFilter {
  equal: ID
  isAnyOf: [ID!]
  notEqual: ID
}

type ImageCropArea {
  focalPoint: FocalPoint!
  height: Float
  width: Float
  x: Float
  y: Float
}

input ImageCropAreaInput {
  focalPoint: FocalPoint!
  height: Float
  width: Float
  x: Float
  y: Float
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type KubernetesCronJob {
  id: ID!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  lastJobRun: KubernetesJob
  lastScheduledAt: DateTime
  name: String!
  schedule: String!
}

type KubernetesJob {
  completionTime: DateTime
  id: ID!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  name: String!
  startTime: DateTime
  status: KubernetesJobStatus!
}

enum KubernetesJobStatus {
  active
  failed
  pending
  succeeded
}

input LicenseInput {
  author: String
  details: String
  durationFrom: DateTime
  durationTo: DateTime
  type: LicenseType
}

enum LicenseType {
  RIGHTS_MANAGED
  ROYALTY_FREE
}

"""
A local date string (i.e., with no associated timezone) in `YYYY-MM-DD` format, e.g. `2020-01-01`.
"""
scalar LocalDate

type Manufacturer {
  address: Address
  addressAsEmbeddable: AddressAsEmbeddable!
  coordinates: Coordinates
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type ManufacturerCountry {
  id: String!
  label: String!
  used: Float!
}

input ManufacturerCountryFilter {
  and: [ManufacturerCountryFilter!]
  id: StringFilter
  label: StringFilter
  or: [ManufacturerCountryFilter!]
  used: NumberFilter
}

input ManufacturerFilter {
  addressAsEmbeddable_alternativeAddress_country: StringFilter
  addressAsEmbeddable_alternativeAddress_street: StringFilter
  addressAsEmbeddable_alternativeAddress_streetNumber: NumberFilter
  addressAsEmbeddable_alternativeAddress_zip: StringFilter
  addressAsEmbeddable_country: StringFilter
  addressAsEmbeddable_street: StringFilter
  addressAsEmbeddable_streetNumber: NumberFilter
  addressAsEmbeddable_zip: StringFilter
  and: [ManufacturerFilter!]
  id: IdFilter
  name: StringFilter
  or: [ManufacturerFilter!]
  updatedAt: DateTimeFilter
}

input ManufacturerInput {
  address: AddressInput
  addressAsEmbeddable: AddressAsEmbeddableInput!
  coordinates: CoordinatesInput
  name: String!
}

input ManufacturerSort {
  direction: SortDirection! = ASC
  field: ManufacturerSortField!
}

enum ManufacturerSortField {
  addressAsEmbeddable_alternativeAddress_country
  addressAsEmbeddable_alternativeAddress_street
  addressAsEmbeddable_alternativeAddress_streetNumber
  addressAsEmbeddable_alternativeAddress_zip
  addressAsEmbeddable_country
  addressAsEmbeddable_street
  addressAsEmbeddable_streetNumber
  addressAsEmbeddable_zip
  name
  updatedAt
}

input ManufacturerUpdateInput {
  address: AddressInput
  addressAsEmbeddable: AddressAsEmbeddableInput
  coordinates: CoordinatesInput
  name: String
}

input ManyToManyFilter {
  contains: ID
  isAnyOf: [ID!]
  search: String
}

input ManyToOneFilter {
  equal: ID
  isAnyOf: [ID!]
  notEqual: ID
}

type MappedFile {
  copy: DamFile!
  rootFile: DamFile!
}

type Mutation {
  archiveDamFile(id: ID!): DamFile!
  archiveDamFiles(ids: [ID!]!): [DamFile!]!
  copyFilesToScope(fileIds: [ID!]!, inboxFolderId: ID!): CopyFilesResponse!
  createBuilds(input: CreateBuildsInput!): Boolean!
  createDamFolder(input: CreateDamFolderInput!, scope: DamScopeInput!): DamFolder!
  createDamMediaAlternative(alternative: ID!, for: ID!, input: DamMediaAlternativeInput!): DamMediaAlternative!
  createManufacturer(input: ManufacturerInput!): Manufacturer!
  createNews(input: NewsInput!, scope: NewsContentScopeInput!): News!
  createNewsComment(input: NewsCommentInput!, newsId: ID!): NewsComment!
  createProduct(input: ProductInput!): Product!
  createProductCategory(input: ProductCategoryInput!): ProductCategory!
  createProductCategoryType(input: ProductCategoryTypeInput!): ProductCategoryType!
  createProductHighlight(input: ProductHighlightInput!): ProductHighlight!
  createProductTag(input: ProductTagInput!): ProductTag!
  createProductVariant(input: ProductVariantInput!, product: ID!): ProductVariant!
  currentUserSignOut: String!
  deleteDamFile(id: ID!): Boolean!
  deleteDamFolder(id: ID!): Boolean!
  deleteDamMediaAlternative(id: ID!): Boolean!
  deleteManufacturer(id: ID!): Boolean!
  deleteNews(id: ID!): Boolean!
  deleteNewsComment(id: ID!): Boolean!
  deleteProduct(id: ID!): Boolean!
  deleteProductCategory(id: ID!): Boolean!
  deleteProductCategoryType(id: ID!): Boolean!
  deleteProductHighlight(id: ID!): Boolean!
  deleteProductTag(id: ID!): Boolean!
  deleteProductVariant(id: ID!): Boolean!
  importDamFileByDownload(input: UpdateDamFileInput!, scope: DamScopeInput!, url: String!): DamFile!
  moveDamFiles(fileIds: [ID!]!, targetFolderId: ID): [DamFile!]!
  moveDamFolders(folderIds: [ID!]!, scope: DamScopeInput!, targetFolderId: ID): [DamFolder!]!
  publishAllProducts: Boolean!
  restoreDamFile(id: ID!): DamFile!
  restoreDamFiles(ids: [ID!]!): [DamFile!]!
  triggerKubernetesCronJob(name: String!): KubernetesJob!
  updateDamFile(id: ID!, input: UpdateDamFileInput!): DamFile!
  updateDamFolder(id: ID!, input: UpdateDamFolderInput!): DamFolder!
  updateDamMediaAlternative(id: ID!, input: DamMediaAlternativeUpdateInput!): DamMediaAlternative!
  updateManufacturer(id: ID!, input: ManufacturerUpdateInput!): Manufacturer!
  updateNews(id: ID!, input: NewsUpdateInput!): News!
  updateNewsComment(id: ID!, input: NewsCommentInput!): NewsComment!
  updateProduct(id: ID!, input: ProductUpdateInput!): Product!
  updateProductCategory(id: ID!, input: ProductCategoryUpdateInput!): ProductCategory!
  updateProductCategoryType(id: ID!, input: ProductCategoryTypeUpdateInput!): ProductCategoryType!
  updateProductHighlight(id: ID!, input: ProductHighlightUpdateInput!): ProductHighlight!
  updateProductTag(id: ID!, input: ProductTagUpdateInput!): ProductTag!
  updateProductVariant(id: ID!, input: ProductVariantUpdateInput!): ProductVariant!
  userPermissionsCreatePermission(input: UserPermissionInput!, userId: String!): UserPermission!
  userPermissionsDeletePermission(id: ID!): Boolean!
  userPermissionsUpdateContentScopes(input: UserContentScopesInput!, userId: String!): Boolean!
  userPermissionsUpdateOverrideContentScopes(input: UserPermissionOverrideContentScopesInput!): UserPermission!
  userPermissionsUpdatePermission(id: String!, input: UserPermissionInput!): UserPermission!
}

type News {
  category: NewsCategory!
  comments: [NewsComment!]!
  content: NewsContentBlockData!
  createdAt: DateTime!
  date: DateTime!
  dependencies(filter: DependencyFilter, forceRefresh: Boolean! = false, limit: Int! = 25, offset: Int! = 0): PaginatedDependencies!
  dependents(filter: DependentFilter, forceRefresh: Boolean! = false, limit: Int! = 25, offset: Int! = 0): PaginatedDependencies!
  id: ID!
  image: DamImageBlockData!
  scope: NewsContentScope!
  slug: String!
  status: NewsStatus!
  title: String!
  updatedAt: DateTime!
}

enum NewsCategory {
  awards
  company
  events
}

input NewsCategoryEnumFilter {
  equal: NewsCategory
  isAnyOf: [NewsCategory!]
  notEqual: NewsCategory
}

type NewsComment {
  comment: String!
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
}

input NewsCommentInput {
  comment: String!
}

"""NewsContent root block data"""
scalar NewsContentBlockData @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""NewsContent root block input"""
scalar NewsContentBlockInput @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type NewsContentScope {
  domain: String!
  language: String!
}

input NewsContentScopeInput {
  domain: String!
  language: String!
}

input NewsFilter {
  and: [NewsFilter!]
  category: NewsCategoryEnumFilter
  comments: OneToManyFilter
  createdAt: DateTimeFilter
  date: DateTimeFilter
  id: IdFilter
  or: [NewsFilter!]
  slug: StringFilter
  status: NewsStatusEnumFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input NewsInput {
  category: NewsCategory!
  content: NewsContentBlockInput!
  date: DateTime!
  image: DamImageBlockInput!
  slug: String!
  status: NewsStatus! = active
  title: String!
}

input NewsSort {
  direction: SortDirection! = ASC
  field: NewsSortField!
}

enum NewsSortField {
  category
  createdAt
  date
  slug
  status
  title
  updatedAt
}

enum NewsStatus {
  active
  deleted
}

input NewsStatusEnumFilter {
  equal: NewsStatus
  isAnyOf: [NewsStatus!]
  notEqual: NewsStatus
}

input NewsUpdateInput {
  category: NewsCategory
  content: NewsContentBlockInput
  date: DateTime
  image: DamImageBlockInput
  slug: String
  status: NewsStatus
  title: String
}

input NumberFilter {
  equal: Float
  greaterThan: Float
  greaterThanEqual: Float
  isAnyOf: [Float!]
  isEmpty: Boolean
  isNotEmpty: Boolean
  lowerThan: Float
  lowerThanEqual: Float
  notEqual: Float
}

input OneToManyFilter {
  contains: ID
  isAnyOf: [ID!]
  search: String
}

type PaginatedDamFiles {
  nodes: [DamFile!]!
  totalCount: Int!
}

type PaginatedDamFolders {
  nodes: [DamFolder!]!
  totalCount: Int!
}

type PaginatedDamItems {
  nodes: [DamItem!]!
  totalCount: Int!
}

type PaginatedDamMediaAlternatives {
  nodes: [DamMediaAlternative!]!
  totalCount: Int!
}

type PaginatedDependencies {
  nodes: [Dependency!]!
  totalCount: Int!
}

type PaginatedManufacturerCountries {
  nodes: [ManufacturerCountry!]!
  totalCount: Int!
}

type PaginatedManufacturers {
  nodes: [Manufacturer!]!
  totalCount: Int!
}

type PaginatedNews {
  nodes: [News!]!
  totalCount: Int!
}

type PaginatedProductCategories {
  nodes: [ProductCategory!]!
  totalCount: Int!
}

type PaginatedProductCategoryTypes {
  nodes: [ProductCategoryType!]!
  totalCount: Int!
}

type PaginatedProductHighlights {
  nodes: [ProductHighlight!]!
  totalCount: Int!
}

type PaginatedProductTags {
  nodes: [ProductTag!]!
  totalCount: Int!
}

type PaginatedProductVariants {
  nodes: [ProductVariant!]!
  totalCount: Int!
}

type PaginatedProducts {
  nodes: [Product!]!
  totalCount: Int!
}

type PaginatedWarnings {
  nodes: [Warning!]!
  totalCount: Int!
}

enum Permission {
  blockPreview
  builds
  cronJobs
  dam
  dependencies
  fileUploads
  impersonation
  manufacturers
  news
  pageTree
  prelogin
  products
  sitePreview
  translation
  userPermissions
  warnings
}

input PermissionFilter {
  equal: Permission
  isAnyOf: [Permission!]
  notEqual: Permission
}

type Product {
  additionalTypes: [ProductType!]!
  articleNumbers: [String!]!
  availableSince: LocalDate
  category: ProductCategory
  colors: [ProductColor!]!
  createdAt: DateTime!
  datasheets: [FileUpload!]!
  description: String
  dimensions: ProductDimensions
  discounts: [ProductDiscounts!]!
  id: ID!
  image: DamImageBlockData!
  inStock: Boolean!
  lastCheckedAt: DateTime
  manufacturer: Manufacturer
  price: Float
  priceList: FileUpload
  priceRange: ProductPriceRange
  slug: String!
  soldCount: Int
  statistics: ProductStatistics
  status: ProductStatus!
  tags: [ProductTag!]!
  tagsWithStatus: [ProductToTag!]!
  title: String!
  type: ProductType!
  updatedAt: DateTime!
  variants: [ProductVariant!]!
}

type ProductCategory {
  createdAt: DateTime!
  id: ID!
  position: Int!
  products: [Product!]!
  slug: String!
  title: String!
  type: ProductCategoryType
  updatedAt: DateTime!
}

input ProductCategoryFilter {
  and: [ProductCategoryFilter!]
  createdAt: DateTimeFilter
  id: IdFilter
  or: [ProductCategoryFilter!]
  products: OneToManyFilter
  slug: StringFilter
  title: StringFilter
  type: ManyToOneFilter
  updatedAt: DateTimeFilter
}

input ProductCategoryInput {
  position: Int
  products: [ID!]! = []
  slug: String!
  title: String!
  type: ID = null
}

input ProductCategorySort {
  direction: SortDirection! = ASC
  field: ProductCategorySortField!
}

enum ProductCategorySortField {
  createdAt
  position
  slug
  title
  type
  type_title
  updatedAt
}

type ProductCategoryType {
  categories: [ProductCategory!]!
  id: ID!
  title: String!
}

input ProductCategoryTypeFilter {
  and: [ProductCategoryTypeFilter!]
  categories: OneToManyFilter
  id: IdFilter
  or: [ProductCategoryTypeFilter!]
  title: StringFilter
}

input ProductCategoryTypeInput {
  categories: [ID!]! = []
  title: String!
}

input ProductCategoryTypeSort {
  direction: SortDirection! = ASC
  field: ProductCategoryTypeSortField!
}

enum ProductCategoryTypeSortField {
  title
}

input ProductCategoryTypeUpdateInput {
  categories: [ID!]
  title: String
}

input ProductCategoryUpdateInput {
  position: Int
  products: [ID!]
  slug: String
  title: String
  type: ID
}

type ProductColor implements DocumentInterface {
  createdAt: DateTime!
  hexCode: String!
  id: ID!
  name: String!
  product: Product!
  updatedAt: DateTime!
}

type ProductDimensions {
  depth: Float!
  height: Float!
  width: Float!
}

input ProductDimensionsInput {
  depth: Float!
  height: Float!
  width: Float!
}

type ProductDiscounts {
  price: Float!
  quantity: Float!
}

input ProductDiscountsInput {
  price: Float!
  quantity: Float!
}

input ProductFilter {
  additionalTypes: ProductTypeEnumsFilter
  and: [ProductFilter!]
  availableSince: DateFilter
  category: ManyToOneFilter
  colors: OneToManyFilter
  createdAt: DateTimeFilter
  datasheets: ManyToManyFilter
  description: StringFilter
  id: IdFilter
  inStock: BooleanFilter
  lastCheckedAt: DateTimeFilter
  manufacturer: ManyToOneFilter
  or: [ProductFilter!]
  price: NumberFilter
  priceList: ManyToOneFilter
  slug: StringFilter
  soldCount: NumberFilter
  status: ProductStatusEnumFilter
  tags: ManyToManyFilter
  tagsWithStatus: OneToManyFilter
  title: StringFilter
  type: ProductTypeEnumFilter
  updatedAt: DateTimeFilter
  variants: OneToManyFilter
}

type ProductHighlight {
  createdAt: DateTime!
  description: String!
  id: ID!
  product: Product!
  updatedAt: DateTime!
}

input ProductHighlightFilter {
  and: [ProductHighlightFilter!]
  createdAt: DateTimeFilter
  description: StringFilter
  id: IdFilter
  or: [ProductHighlightFilter!]
  product: ManyToOneFilter
  updatedAt: DateTimeFilter
}

input ProductHighlightInput {
  description: String!
  product: ID!
}

input ProductHighlightSort {
  direction: SortDirection! = ASC
  field: ProductHighlightSortField!
}

enum ProductHighlightSortField {
  createdAt
  description
  product
  product_additionalTypes
  product_availableSince
  product_category
  product_createdAt
  product_description
  product_inStock
  product_lastCheckedAt
  product_manufacturer
  product_price
  product_priceList
  product_slug
  product_soldCount
  product_status
  product_title
  product_type
  product_updatedAt
  updatedAt
}

input ProductHighlightUpdateInput {
  description: String
  product: ID
}

input ProductInput {
  additionalTypes: [ProductType!]! = []
  articleNumbers: [String!]! = []
  availableSince: LocalDate = null
  category: ID = null
  colors: [ProductNestedProductColorInput!]! = []
  datasheets: [ID!]! = []
  description: String = null
  dimensions: ProductDimensionsInput
  discounts: [ProductDiscountsInput!]! = []
  image: DamImageBlockInput!
  inStock: Boolean! = true
  lastCheckedAt: DateTime = null
  manufacturer: ID = null
  price: Float = null
  priceList: ID = null
  priceRange: ProductPriceRangeInput
  slug: String!
  statistics: ProductNestedProductStatisticsInput
  status: ProductStatus! = Unpublished
  tags: [ID!]! = []
  tagsWithStatus: [ProductNestedProductToTagInput!]! = []
  title: String!
  type: ProductType!
}

input ProductNestedProductColorInput {
  hexCode: String!
  name: String!
}

input ProductNestedProductStatisticsInput {
  views: Int!
}

input ProductNestedProductToTagInput {
  exampleStatus: Boolean! = true
  tag: ID!
}

type ProductPriceRange {
  max: Float!
  min: Float!
}

input ProductPriceRangeInput {
  max: Float!
  min: Float!
}

input ProductSort {
  direction: SortDirection! = ASC
  field: ProductSortField!
}

enum ProductSortField {
  additionalTypes
  availableSince
  category
  category_createdAt
  category_position
  category_slug
  category_title
  category_type
  category_updatedAt
  createdAt
  description
  inStock
  lastCheckedAt
  manufacturer
  manufacturer_addressAsEmbeddable_alternativeAddress_country
  manufacturer_addressAsEmbeddable_alternativeAddress_street
  manufacturer_addressAsEmbeddable_alternativeAddress_streetNumber
  manufacturer_addressAsEmbeddable_alternativeAddress_zip
  manufacturer_addressAsEmbeddable_country
  manufacturer_addressAsEmbeddable_street
  manufacturer_addressAsEmbeddable_streetNumber
  manufacturer_addressAsEmbeddable_zip
  manufacturer_name
  manufacturer_updatedAt
  price
  priceList
  priceList_contentHash
  priceList_createdAt
  priceList_id
  priceList_mimetype
  priceList_name
  priceList_updatedAt
  slug
  soldCount
  statistics_createdAt
  statistics_updatedAt
  statistics_views
  status
  title
  type
  updatedAt
}

type ProductStatistics {
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
  views: Int!
}

enum ProductStatus {
  Deleted
  Published
  Unpublished
}

input ProductStatusEnumFilter {
  equal: ProductStatus
  isAnyOf: [ProductStatus!]
  notEqual: ProductStatus
}

type ProductTag {
  createdAt: DateTime!
  id: ID!
  products: [Product!]!
  productsWithStatus: [ProductToTag!]!
  title: String!
  updatedAt: DateTime!
}

input ProductTagFilter {
  and: [ProductTagFilter!]
  createdAt: DateTimeFilter
  id: IdFilter
  or: [ProductTagFilter!]
  products: ManyToManyFilter
  productsWithStatus: OneToManyFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input ProductTagInput {
  products: [ID!]! = []
  productsWithStatus: [ProductTagNestedProductToTagInput!]! = []
  title: String!
}

input ProductTagNestedProductToTagInput {
  exampleStatus: Boolean! = true
  product: ID!
}

input ProductTagSort {
  direction: SortDirection! = ASC
  field: ProductTagSortField!
}

enum ProductTagSortField {
  createdAt
  title
  updatedAt
}

input ProductTagUpdateInput {
  products: [ID!]
  productsWithStatus: [ProductTagNestedProductToTagInput!]
  title: String
}

type ProductToTag {
  exampleStatus: Boolean!
  id: String!
  product: Product!
  tag: ProductTag!
}

enum ProductType {
  cap
  shirt
  tie
}

input ProductTypeEnumFilter {
  equal: ProductType
  isAnyOf: [ProductType!]
  notEqual: ProductType
}

input ProductTypeEnumsFilter {
  contains: [ProductType!]
}

input ProductUpdateInput {
  additionalTypes: [ProductType!]
  articleNumbers: [String!]
  availableSince: LocalDate
  category: ID
  colors: [ProductNestedProductColorInput!]
  datasheets: [ID!]
  description: String
  dimensions: ProductDimensionsInput
  discounts: [ProductDiscountsInput!]
  image: DamImageBlockInput
  inStock: Boolean
  lastCheckedAt: DateTime
  manufacturer: ID
  price: Float
  priceList: ID
  priceRange: ProductPriceRangeInput
  slug: String
  statistics: ProductNestedProductStatisticsInput
  status: ProductStatus
  tags: [ID!]
  tagsWithStatus: [ProductNestedProductToTagInput!]
  title: String
  type: ProductType
}

type ProductVariant {
  createdAt: DateTime!
  id: ID!
  image: DamImageBlockData!
  name: String!
  position: Int!
  product: Product!
  updatedAt: DateTime!
}

input ProductVariantFilter {
  and: [ProductVariantFilter!]
  createdAt: DateTimeFilter
  id: IdFilter
  name: StringFilter
  or: [ProductVariantFilter!]
  updatedAt: DateTimeFilter
}

input ProductVariantInput {
  image: DamImageBlockInput!
  name: String!
  position: Int
}

input ProductVariantSort {
  direction: SortDirection! = ASC
  field: ProductVariantSortField!
}

enum ProductVariantSortField {
  createdAt
  name
  position
  product
  product_additionalTypes
  product_availableSince
  product_category
  product_createdAt
  product_description
  product_inStock
  product_lastCheckedAt
  product_manufacturer
  product_price
  product_priceList
  product_slug
  product_soldCount
  product_status
  product_title
  product_type
  product_updatedAt
  updatedAt
}

input ProductVariantUpdateInput {
  image: DamImageBlockInput
  name: String
  position: Int
}

type Query {
  autoBuildStatus: AutoBuildStatus!
  buildTemplates: [BuildTemplate!]!
  builds(limit: Float): [Build!]!
  currentUser: CurrentUser!
  damAreFilenamesOccupied(filenames: [FilenameInput!]!, scope: DamScopeInput!): [FilenameResponse!]!
  damFile(id: ID!): DamFile!
  damFilesList(filter: FileFilterInput, folderId: ID, includeArchived: Boolean = false, limit: Int! = 25, offset: Int! = 0, scope: DamScopeInput!, sortColumnName: String, sortDirection: SortDirection! = ASC): PaginatedDamFiles!
  damFolder(id: ID!): DamFolder!
  damFolderByNameAndParentId(name: String!, parentId: ID, scope: DamScopeInput!): DamFolder
  damFoldersFlat(scope: DamScopeInput!): [DamFolder!]!
  damFoldersList(filter: FolderFilterInput, includeArchived: Boolean, limit: Int! = 25, offset: Int! = 0, parentId: ID, scope: DamScopeInput!, sortColumnName: String, sortDirection: SortDirection! = ASC): PaginatedDamFolders!
  damIsFilenameOccupied(filename: String!, folderId: String, scope: DamScopeInput!): Boolean!
  damItemListPosition(filter: DamItemFilterInput, folderId: ID, id: ID!, includeArchived: Boolean, scope: DamScopeInput!, sortColumnName: String, sortDirection: SortDirection! = ASC, type: DamItemType!): Int!
  damItemsList(filter: DamItemFilterInput, folderId: ID, includeArchived: Boolean, limit: Int! = 25, offset: Int! = 0, scope: DamScopeInput!, sortColumnName: String, sortDirection: SortDirection! = ASC): PaginatedDamItems!
  damMediaAlternative(id: ID!): DamMediaAlternative!
  damMediaAlternatives(alternative: ID, for: ID, limit: Int! = 25, offset: Int! = 0, search: String, sort: [DamMediaAlternativeSort!], type: DamMediaAlternativeType): PaginatedDamMediaAlternatives!
  findCopiesOfFileInScope(id: ID!, imageCropArea: ImageCropAreaInput, scope: DamScopeInput!): [DamFile!]!
  kubernetesCronJob(name: String!): KubernetesCronJob!
  kubernetesCronJobs: [KubernetesCronJob!]!
  kubernetesJob(name: String!): KubernetesJob!
  kubernetesJobLogs(name: String!): String!
  kubernetesJobs(cronJobName: String!): [KubernetesJob!]!
  manufacturer(id: ID!): Manufacturer!
  manufacturerCountries(filter: ManufacturerCountryFilter, limit: Int! = 25, offset: Int! = 0, search: String): PaginatedManufacturerCountries!
  manufacturers(filter: ManufacturerFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ManufacturerSort!]): PaginatedManufacturers!
  news(id: ID!): News!
  newsBySlug(scope: NewsContentScopeInput!, slug: String!): News
  newsList(filter: NewsFilter, limit: Int! = 25, offset: Int! = 0, scope: NewsContentScopeInput!, search: String, sort: [NewsSort!]): PaginatedNews!
  newsListByIds(ids: [ID!]!): [News!]!
  product(id: ID!): Product!
  productBySlug(slug: String!): Product
  productCategories(filter: ProductCategoryFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductCategorySort!]): PaginatedProductCategories!
  productCategory(id: ID!): ProductCategory!
  productCategoryBySlug(slug: String!): ProductCategory
  productCategoryType(id: ID!): ProductCategoryType!
  productCategoryTypes(filter: ProductCategoryTypeFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductCategoryTypeSort!]): PaginatedProductCategoryTypes!
  productHighlight(id: ID!): ProductHighlight!
  productHighlights(filter: ProductHighlightFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductHighlightSort!]): PaginatedProductHighlights!
  productTag(id: ID!): ProductTag!
  productTags(filter: ProductTagFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductTagSort!]): PaginatedProductTags!
  productVariant(id: ID!): ProductVariant!
  productVariants(filter: ProductVariantFilter, limit: Int! = 25, offset: Int! = 0, product: ID!, search: String, sort: [ProductVariantSort!]): PaginatedProductVariants!
  products(filter: ProductFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductSort!]): PaginatedProducts!
  userPermissionsAvailableContentScopes: [ContentScopeWithLabel!]!
  userPermissionsAvailablePermissions: [String!]!
  userPermissionsContentScopes(skipManual: Boolean, userId: String!): [JSONObject!]!
  userPermissionsPermission(id: ID!, userId: String): UserPermission!
  userPermissionsPermissionList(userId: String!): [UserPermission!]!
  userPermissionsUserById(id: String!): UserPermissionsUser!
  userPermissionsUsers(filter: UserPermissionsUserFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [UserPermissionsUserSort!]): UserPermissionPaginatedUserList!
  warning(id: ID!): Warning!
  warnings(filter: WarningFilter, limit: Int! = 25, offset: Int! = 0, scopes: [JSONObject!]!, search: String, sort: [WarningSort!], status: [WarningStatus!]! = [open]): PaginatedWarnings!
}

input ScopeFilter {
  equal: JSONObject
  isAnyOf: [JSONObject!]
  notEqual: JSONObject
}

enum SortDirection {
  ASC
  DESC
}

input StringFilter {
  contains: String
  endsWith: String
  equal: String
  isAnyOf: [String!]
  isEmpty: Boolean
  isNotEmpty: Boolean
  notContains: String
  notEqual: String
  startsWith: String
}

input UpdateDamFileInput {
  altText: String
  folderId: ID
  image: UpdateImageFileInput
  license: LicenseInput
  name: String
  title: String
}

input UpdateDamFolderInput {
  archived: Boolean
  name: String
  parentId: ID
}

input UpdateImageFileInput {
  cropArea: ImageCropAreaInput
}

input UserContentScopesInput {
  contentScopes: [JSONObject!]! = []
}

type UserPermission {
  approvedBy: String
  contentScopes: [JSONObject!]!
  id: ID!
  overrideContentScopes: Boolean!
  permission: Permission!
  reason: String
  requestedBy: String
  source: UserPermissionSource!
  validFrom: DateTime
  validTo: DateTime
}

input UserPermissionInput {
  approvedBy: String
  permission: Permission!
  reason: String
  requestedBy: String
  validFrom: DateTime
  validTo: DateTime
}

input UserPermissionOverrideContentScopesInput {
  contentScopes: [JSONObject!]! = []
  overrideContentScopes: Boolean!
  permissionId: ID!
}

type UserPermissionPaginatedUserList {
  nodes: [UserPermissionsUser!]!
  totalCount: Int!
}

enum UserPermissionSource {
  BY_RULE
  MANUAL
}

type UserPermissionsUser {
  contentScopesCount: Int!
  email: String!
  id: String!
  impersonationAllowed: Boolean!
  name: String!
  permissionsCount: Int!
}

input UserPermissionsUserFilter {
  and: [UserPermissionsUserFilter!]
  email: StringFilter
  name: StringFilter
  or: [UserPermissionsUserFilter!]
  permission: PermissionFilter
  status: StringFilter
}

input UserPermissionsUserSort {
  direction: SortDirection! = ASC
  field: UserPermissionsUserSortField!
}

enum UserPermissionsUserSortField {
  email
  name
  status
}

type Warning {
  createdAt: DateTime!
  entityInfo: EntityInfo
  id: ID!
  message: String!
  scope: JSONObject
  severity: WarningSeverity!
  sourceInfo: WarningSourceInfo!
  status: WarningStatus!
  updatedAt: DateTime!
}

input WarningFilter {
  and: [WarningFilter!]
  createdAt: DateTimeFilter
  message: StringFilter
  or: [WarningFilter!]
  scope: ScopeFilter
  severity: WarningSeverityEnumFilter
  status: WarningStatusEnumFilter
  type: StringFilter
  updatedAt: DateTimeFilter
}

enum WarningSeverity {
  high
  low
  medium
}

input WarningSeverityEnumFilter {
  equal: WarningSeverity
  isAnyOf: [WarningSeverity!]
  notEqual: WarningSeverity
}

input WarningSort {
  direction: SortDirection! = ASC
  field: WarningSortField!
}

enum WarningSortField {
  createdAt
  message
  severity
  status
  type
  updatedAt
}

type WarningSourceInfo {
  jsonPath: String
  rootColumnName: String
  rootEntityName: String!
  rootPrimaryKey: String!
  targetId: String!
}

input WarningSourceInfoInput {
  jsonPath: String
  rootColumnName: String
  rootEntityName: String!
  rootPrimaryKey: String!
  targetId: String!
}

enum WarningStatus {
  ignored
  open
  resolved
}

input WarningStatusEnumFilter {
  equal: WarningStatus
  isAnyOf: [WarningStatus!]
  notEqual: WarningStatus
}