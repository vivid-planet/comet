# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Address {
  alternativeAddress: AlternativeAddress
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

type AddressAsEmbeddable {
  alternativeAddress: AlternativeAddressAsEmbeddable!
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

input AddressAsEmbeddableInput {
  alternativeAddress: AlternativeAddressAsEmbeddableInput!
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

input AddressInput {
  alternativeAddress: AlternativeAddressInput
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

type AlternativeAddress {
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

type AlternativeAddressAsEmbeddable {
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

input AlternativeAddressAsEmbeddableInput {
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

input AlternativeAddressInput {
  country: String!
  street: String!
  streetNumber: Float
  zip: String!
}

type AutoBuildStatus {
  hasChangesSinceLastBuild: Boolean!
  lastCheck: DateTime
  nextCheck: DateTime!
}

input BooleanFilter {
  equal: Boolean
}

type Build {
  completionTime: DateTime
  estimatedCompletionTime: DateTime
  id: ID!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  name: String
  startTime: DateTime
  status: KubernetesJobStatus!
  trigger: String
}

type BuildTemplate {
  id: ID!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  name: String!
}

type ContentScopeWithLabel {
  label: JSONObject!
  scope: JSONObject!
}

type Coordinates {
  latitude: Float!
  longitude: Float!
}

input CoordinatesInput {
  latitude: Float!
  longitude: Float!
}

input CreateBuildsInput {
  names: [String!]!
}

type CurrentUser {
  allowedContentScopes: [ContentScopeWithLabel!]!
  authenticatedUser: UserPermissionsUser
  email: String!
  id: String!
  impersonated: Boolean
  name: String!
  permissions: [CurrentUserPermission!]!
  permissionsForScope(scope: JSONObject!): [String!]!
}

type CurrentUserPermission {
  contentScopes: [JSONObject!]!
  permission: Permission!
}

type DamMediaAlternative {
  id: ID!
  language: String!
  type: DamMediaAlternativeType!
}

enum DamMediaAlternativeType {
  captions
}

input DateFilter {
  equal: LocalDate
  greaterThan: LocalDate
  greaterThanEqual: LocalDate
  isEmpty: Boolean
  isNotEmpty: Boolean
  lowerThan: LocalDate
  lowerThanEqual: LocalDate
  notEqual: LocalDate
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equal: DateTime
  greaterThan: DateTime
  greaterThanEqual: DateTime
  isEmpty: Boolean
  isNotEmpty: Boolean
  lowerThan: DateTime
  lowerThanEqual: DateTime
  notEqual: DateTime
}

type Department {
  createdAt: DateTime!
  id: ID!
  name: String!
  tenant: Tenant!
  updatedAt: DateTime!
}

input DepartmentFilter {
  and: [DepartmentFilter!]
  createdAt: DateTimeFilter
  id: IdFilter
  name: StringFilter
  or: [DepartmentFilter!]
  updatedAt: DateTimeFilter
}

input DepartmentInput {
  name: String!
}

input DepartmentSort {
  direction: SortDirection! = ASC
  field: DepartmentSortField!
}

enum DepartmentSortField {
  createdAt
  name
  tenant
  tenant_createdAt
  tenant_name
  tenant_updatedAt
  updatedAt
}

input DepartmentUpdateInput {
  name: String
}

type Dependency {
  jsonPath: String!
  name: String
  rootColumnName: String!
  rootGraphqlObjectType: String!
  rootId: String!
  secondaryInformation: String
  targetGraphqlObjectType: String!
  targetId: String!
  visible: Boolean!
}

interface DocumentInterface {
  id: ID!
  updatedAt: DateTime!
}

type FileUpload {
  contentHash: String!
  createdAt: DateTime!
  downloadUrl: String!
  id: ID!
  imageUrl(resizeWidth: Int!): String
  mimetype: String!
  name: String!
  previewUrl: String!
  size: Int!
  updatedAt: DateTime!
}

enum FocalPoint {
  CENTER
  NORTHEAST
  NORTHWEST
  SMART
  SOUTHEAST
  SOUTHWEST
}

input IdFilter {
  equal: ID
  isAnyOf: [ID!]
  notEqual: ID
}

type ImageCropArea {
  focalPoint: FocalPoint!
  height: Float
  width: Float
  x: Float
  y: Float
}

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type KubernetesCronJob {
  id: ID!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  lastJobRun: KubernetesJob
  lastScheduledAt: DateTime
  name: String!
  schedule: String!
}

type KubernetesJob {
  completionTime: DateTime
  id: ID!

  """
  Human readable label provided by comet-dxp.com/label annotation. Use name as fallback if not present
  """
  label: String
  name: String!
  startTime: DateTime
  status: KubernetesJobStatus!
}

enum KubernetesJobStatus {
  active
  failed
  pending
  succeeded
}

"""
A local date string (i.e., with no associated timezone) in `YYYY-MM-DD` format, e.g. `2020-01-01`.
"""
scalar LocalDate

type Manufacturer {
  address: Address
  addressAsEmbeddable: AddressAsEmbeddable!
  coordinates: Coordinates
  id: ID!
  name: String!
  updatedAt: DateTime!
}

type ManufacturerCountry {
  id: String!
  label: String!
  used: Float!
}

input ManufacturerCountryFilter {
  and: [ManufacturerCountryFilter!]
  id: StringFilter
  label: StringFilter
  or: [ManufacturerCountryFilter!]
  used: NumberFilter
}

input ManufacturerFilter {
  addressAsEmbeddable_alternativeAddress_country: StringFilter
  addressAsEmbeddable_alternativeAddress_street: StringFilter
  addressAsEmbeddable_alternativeAddress_streetNumber: NumberFilter
  addressAsEmbeddable_alternativeAddress_zip: StringFilter
  addressAsEmbeddable_country: StringFilter
  addressAsEmbeddable_street: StringFilter
  addressAsEmbeddable_streetNumber: NumberFilter
  addressAsEmbeddable_zip: StringFilter
  and: [ManufacturerFilter!]
  id: IdFilter
  name: StringFilter
  or: [ManufacturerFilter!]
  updatedAt: DateTimeFilter
}

input ManufacturerInput {
  address: AddressInput
  addressAsEmbeddable: AddressAsEmbeddableInput!
  coordinates: CoordinatesInput
  name: String!
}

input ManufacturerSort {
  direction: SortDirection! = ASC
  field: ManufacturerSortField!
}

enum ManufacturerSortField {
  addressAsEmbeddable_alternativeAddress_country
  addressAsEmbeddable_alternativeAddress_street
  addressAsEmbeddable_alternativeAddress_streetNumber
  addressAsEmbeddable_alternativeAddress_zip
  addressAsEmbeddable_country
  addressAsEmbeddable_street
  addressAsEmbeddable_streetNumber
  addressAsEmbeddable_zip
  name
  updatedAt
}

input ManufacturerUpdateInput {
  address: AddressInput
  addressAsEmbeddable: AddressAsEmbeddableInput
  coordinates: CoordinatesInput
  name: String
}

input ManyToManyFilter {
  contains: ID
  isAnyOf: [ID!]
  search: String
}

input ManyToOneFilter {
  equal: ID
  isAnyOf: [ID!]
  notEqual: ID
}

type Mutation {
  assignTenantUser(tenant: ID!, userId: String!): TenantUser!
  createBuilds(input: CreateBuildsInput!): Boolean!
  createDepartment(input: DepartmentInput!, tenant: ID!): Department!
  createManufacturer(input: ManufacturerInput!): Manufacturer!
  createProduct(input: ProductInput!): Product!
  createProductCategory(input: ProductCategoryInput!): ProductCategory!
  createProductCategoryType(input: ProductCategoryTypeInput!): ProductCategoryType!
  createProductHighlight(input: ProductHighlightInput!): ProductHighlight!
  createProductTag(input: ProductTagInput!): ProductTag!
  createProductVariant(input: ProductVariantInput!, product: ID!): ProductVariant!
  createTenant(input: TenantInput!): Tenant!
  currentUserSignOut: String!
  deleteManufacturer(id: ID!): Boolean!
  deleteProduct(id: ID!): Boolean!
  deleteProductCategory(id: ID!): Boolean!
  deleteProductCategoryType(id: ID!): Boolean!
  deleteProductHighlight(id: ID!): Boolean!
  deleteProductTag(id: ID!): Boolean!
  deleteProductVariant(id: ID!): Boolean!
  deleteTenantUser(id: ID!): Boolean!
  publishAllProducts: Boolean!
  triggerKubernetesCronJob(name: String!): KubernetesJob!
  updateDepartment(id: ID!, input: DepartmentUpdateInput!): Department!
  updateManufacturer(id: ID!, input: ManufacturerUpdateInput!): Manufacturer!
  updateProduct(id: ID!, input: ProductUpdateInput!): Product!
  updateProductCategory(id: ID!, input: ProductCategoryUpdateInput!): ProductCategory!
  updateProductCategoryType(id: ID!, input: ProductCategoryTypeUpdateInput!): ProductCategoryType!
  updateProductHighlight(id: ID!, input: ProductHighlightUpdateInput!): ProductHighlight!
  updateProductTag(id: ID!, input: ProductTagUpdateInput!): ProductTag!
  updateProductVariant(id: ID!, input: ProductVariantUpdateInput!): ProductVariant!
  updateTenant(id: ID!, input: TenantUpdateInput!): Tenant!
  userPermissionsCreatePermission(input: UserPermissionInput!, userId: String!): UserPermission!
  userPermissionsDeletePermission(id: ID!): Boolean!
  userPermissionsUpdateContentScopes(input: UserContentScopesInput!, userId: String!): Boolean!
  userPermissionsUpdateOverrideContentScopes(input: UserPermissionOverrideContentScopesInput!): UserPermission!
  userPermissionsUpdatePermission(id: String!, input: UserPermissionInput!): UserPermission!
}

input NumberFilter {
  equal: Float
  greaterThan: Float
  greaterThanEqual: Float
  isAnyOf: [Float!]
  isEmpty: Boolean
  isNotEmpty: Boolean
  lowerThan: Float
  lowerThanEqual: Float
  notEqual: Float
}

input OneToManyFilter {
  contains: ID
  isAnyOf: [ID!]
  search: String
}

type PaginatedDepartments {
  nodes: [Department!]!
  totalCount: Int!
}

type PaginatedManufacturerCountries {
  nodes: [ManufacturerCountry!]!
  totalCount: Int!
}

type PaginatedManufacturers {
  nodes: [Manufacturer!]!
  totalCount: Int!
}

type PaginatedProductCategories {
  nodes: [ProductCategory!]!
  totalCount: Int!
}

type PaginatedProductCategoryTypes {
  nodes: [ProductCategoryType!]!
  totalCount: Int!
}

type PaginatedProductHighlights {
  nodes: [ProductHighlight!]!
  totalCount: Int!
}

type PaginatedProductTags {
  nodes: [ProductTag!]!
  totalCount: Int!
}

type PaginatedProductVariants {
  nodes: [ProductVariant!]!
  totalCount: Int!
}

type PaginatedProducts {
  nodes: [Product!]!
  totalCount: Int!
}

type PaginatedTenantUsers {
  nodes: [TenantUser!]!
  totalCount: Int!
}

type PaginatedTenants {
  nodes: [Tenant!]!
  totalCount: Int!
}

enum Permission {
  blockPreview
  builds
  cronJobs
  dam
  dependencies
  fileUploads
  impersonation
  manufacturers
  news
  pageTree
  prelogin
  products
  sitePreview
  tenantAdministration
  translation
  userPermissions
  warnings
}

input PermissionFilter {
  equal: Permission
  isAnyOf: [Permission!]
  notEqual: Permission
}

type Product {
  additionalTypes: [ProductType!]!
  articleNumbers: [String!]!
  availableSince: LocalDate
  category: ProductCategory
  colors: [ProductColor!]!
  createdAt: DateTime!
  datasheets: [FileUpload!]!
  description: String
  dimensions: ProductDimensions
  discounts: [ProductDiscounts!]!
  id: ID!
  image: FileUpload
  inStock: Boolean!
  lastCheckedAt: DateTime
  manufacturer: Manufacturer
  price: Float
  priceList: FileUpload
  priceRange: ProductPriceRange
  slug: String!
  soldCount: Int
  statistics: ProductStatistics
  status: ProductStatus!
  tags: [ProductTag!]!
  tagsWithStatus: [ProductToTag!]!
  title: String!
  type: ProductType!
  updatedAt: DateTime!
  variants: [ProductVariant!]!
}

type ProductCategory {
  createdAt: DateTime!
  id: ID!
  position: Int!
  products: [Product!]!
  slug: String!
  title: String!
  type: ProductCategoryType
  updatedAt: DateTime!
}

input ProductCategoryFilter {
  and: [ProductCategoryFilter!]
  createdAt: DateTimeFilter
  id: IdFilter
  or: [ProductCategoryFilter!]
  products: OneToManyFilter
  slug: StringFilter
  title: StringFilter
  type: ManyToOneFilter
  updatedAt: DateTimeFilter
}

input ProductCategoryInput {
  position: Int
  products: [ID!]! = []
  slug: String!
  title: String!
  type: ID = null
}

input ProductCategorySort {
  direction: SortDirection! = ASC
  field: ProductCategorySortField!
}

enum ProductCategorySortField {
  createdAt
  position
  slug
  title
  type
  type_title
  updatedAt
}

type ProductCategoryType {
  categories: [ProductCategory!]!
  id: ID!
  title: String!
}

input ProductCategoryTypeFilter {
  and: [ProductCategoryTypeFilter!]
  categories: OneToManyFilter
  id: IdFilter
  or: [ProductCategoryTypeFilter!]
  title: StringFilter
}

input ProductCategoryTypeInput {
  categories: [ID!]! = []
  title: String!
}

input ProductCategoryTypeSort {
  direction: SortDirection! = ASC
  field: ProductCategoryTypeSortField!
}

enum ProductCategoryTypeSortField {
  title
}

input ProductCategoryTypeUpdateInput {
  categories: [ID!]
  title: String
}

input ProductCategoryUpdateInput {
  position: Int
  products: [ID!]
  slug: String
  title: String
  type: ID
}

type ProductColor implements DocumentInterface {
  createdAt: DateTime!
  hexCode: String!
  id: ID!
  name: String!
  product: Product!
  updatedAt: DateTime!
}

type ProductDimensions {
  depth: Float!
  height: Float!
  width: Float!
}

input ProductDimensionsInput {
  depth: Float!
  height: Float!
  width: Float!
}

type ProductDiscounts {
  price: Float!
  quantity: Float!
}

input ProductDiscountsInput {
  price: Float!
  quantity: Float!
}

input ProductFilter {
  additionalTypes: ProductTypeEnumsFilter
  and: [ProductFilter!]
  availableSince: DateFilter
  category: ManyToOneFilter
  colors: OneToManyFilter
  createdAt: DateTimeFilter
  datasheets: ManyToManyFilter
  description: StringFilter
  id: IdFilter
  image: ManyToOneFilter
  inStock: BooleanFilter
  lastCheckedAt: DateTimeFilter
  manufacturer: ManyToOneFilter
  or: [ProductFilter!]
  price: NumberFilter
  priceList: ManyToOneFilter
  slug: StringFilter
  soldCount: NumberFilter
  status: ProductStatusEnumFilter
  tags: ManyToManyFilter
  tagsWithStatus: OneToManyFilter
  title: StringFilter
  type: ProductTypeEnumFilter
  updatedAt: DateTimeFilter
  variants: OneToManyFilter
}

type ProductHighlight {
  createdAt: DateTime!
  description: String!
  id: ID!
  product: Product!
  updatedAt: DateTime!
}

input ProductHighlightFilter {
  and: [ProductHighlightFilter!]
  createdAt: DateTimeFilter
  description: StringFilter
  id: IdFilter
  or: [ProductHighlightFilter!]
  product: ManyToOneFilter
  updatedAt: DateTimeFilter
}

input ProductHighlightInput {
  description: String!
  product: ID!
}

input ProductHighlightSort {
  direction: SortDirection! = ASC
  field: ProductHighlightSortField!
}

enum ProductHighlightSortField {
  createdAt
  description
  product
  product_additionalTypes
  product_availableSince
  product_category
  product_createdAt
  product_description
  product_image
  product_inStock
  product_lastCheckedAt
  product_manufacturer
  product_price
  product_priceList
  product_slug
  product_soldCount
  product_status
  product_title
  product_type
  product_updatedAt
  updatedAt
}

input ProductHighlightUpdateInput {
  description: String
  product: ID
}

input ProductInput {
  additionalTypes: [ProductType!]! = []
  articleNumbers: [String!]! = []
  availableSince: LocalDate = null
  category: ID = null
  colors: [ProductNestedProductColorInput!]! = []
  datasheets: [ID!]! = []
  description: String = null
  dimensions: ProductDimensionsInput
  discounts: [ProductDiscountsInput!]! = []
  image: ID = null
  inStock: Boolean! = true
  lastCheckedAt: DateTime = null
  manufacturer: ID = null
  price: Float = null
  priceList: ID = null
  priceRange: ProductPriceRangeInput
  slug: String!
  statistics: ProductNestedProductStatisticsInput
  status: ProductStatus! = Unpublished
  tags: [ID!]! = []
  tagsWithStatus: [ProductNestedProductToTagInput!]! = []
  title: String!
  type: ProductType!
}

input ProductNestedProductColorInput {
  hexCode: String!
  name: String!
}

input ProductNestedProductStatisticsInput {
  views: Int!
}

input ProductNestedProductToTagInput {
  exampleStatus: Boolean! = true
  tag: ID!
}

type ProductPriceRange {
  max: Float!
  min: Float!
}

input ProductPriceRangeInput {
  max: Float!
  min: Float!
}

input ProductSort {
  direction: SortDirection! = ASC
  field: ProductSortField!
}

enum ProductSortField {
  additionalTypes
  availableSince
  category
  category_createdAt
  category_position
  category_slug
  category_title
  category_type
  category_updatedAt
  createdAt
  description
  image
  image_contentHash
  image_createdAt
  image_id
  image_mimetype
  image_name
  image_updatedAt
  inStock
  lastCheckedAt
  manufacturer
  manufacturer_addressAsEmbeddable_alternativeAddress_country
  manufacturer_addressAsEmbeddable_alternativeAddress_street
  manufacturer_addressAsEmbeddable_alternativeAddress_streetNumber
  manufacturer_addressAsEmbeddable_alternativeAddress_zip
  manufacturer_addressAsEmbeddable_country
  manufacturer_addressAsEmbeddable_street
  manufacturer_addressAsEmbeddable_streetNumber
  manufacturer_addressAsEmbeddable_zip
  manufacturer_name
  manufacturer_updatedAt
  price
  priceList
  priceList_contentHash
  priceList_createdAt
  priceList_id
  priceList_mimetype
  priceList_name
  priceList_updatedAt
  slug
  soldCount
  statistics_createdAt
  statistics_updatedAt
  statistics_views
  status
  title
  type
  updatedAt
}

type ProductStatistics {
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
  views: Int!
}

enum ProductStatus {
  Deleted
  Published
  Unpublished
}

input ProductStatusEnumFilter {
  equal: ProductStatus
  isAnyOf: [ProductStatus!]
  notEqual: ProductStatus
}

type ProductTag {
  createdAt: DateTime!
  id: ID!
  products: [Product!]!
  productsWithStatus: [ProductToTag!]!
  title: String!
  updatedAt: DateTime!
}

input ProductTagFilter {
  and: [ProductTagFilter!]
  createdAt: DateTimeFilter
  id: IdFilter
  or: [ProductTagFilter!]
  products: ManyToManyFilter
  productsWithStatus: OneToManyFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input ProductTagInput {
  products: [ID!]! = []
  productsWithStatus: [ProductTagNestedProductToTagInput!]! = []
  title: String!
}

input ProductTagNestedProductToTagInput {
  exampleStatus: Boolean! = true
  product: ID!
}

input ProductTagSort {
  direction: SortDirection! = ASC
  field: ProductTagSortField!
}

enum ProductTagSortField {
  createdAt
  title
  updatedAt
}

input ProductTagUpdateInput {
  products: [ID!]
  productsWithStatus: [ProductTagNestedProductToTagInput!]
  title: String
}

type ProductToTag {
  exampleStatus: Boolean!
  id: String!
  product: Product!
  tag: ProductTag!
}

enum ProductType {
  cap
  shirt
  tie
}

input ProductTypeEnumFilter {
  equal: ProductType
  isAnyOf: [ProductType!]
  notEqual: ProductType
}

input ProductTypeEnumsFilter {
  contains: [ProductType!]
}

input ProductUpdateInput {
  additionalTypes: [ProductType!]
  articleNumbers: [String!]
  availableSince: LocalDate
  category: ID
  colors: [ProductNestedProductColorInput!]
  datasheets: [ID!]
  description: String
  dimensions: ProductDimensionsInput
  discounts: [ProductDiscountsInput!]
  image: ID
  inStock: Boolean
  lastCheckedAt: DateTime
  manufacturer: ID
  price: Float
  priceList: ID
  priceRange: ProductPriceRangeInput
  slug: String
  statistics: ProductNestedProductStatisticsInput
  status: ProductStatus
  tags: [ID!]
  tagsWithStatus: [ProductNestedProductToTagInput!]
  title: String
  type: ProductType
}

type ProductVariant {
  createdAt: DateTime!
  id: ID!
  image: FileUpload
  name: String!
  position: Int!
  product: Product!
  updatedAt: DateTime!
}

input ProductVariantFilter {
  and: [ProductVariantFilter!]
  createdAt: DateTimeFilter
  id: IdFilter
  image: ManyToOneFilter
  name: StringFilter
  or: [ProductVariantFilter!]
  updatedAt: DateTimeFilter
}

input ProductVariantInput {
  image: ID = null
  name: String!
  position: Int
}

input ProductVariantSort {
  direction: SortDirection! = ASC
  field: ProductVariantSortField!
}

enum ProductVariantSortField {
  createdAt
  image
  image_contentHash
  image_createdAt
  image_id
  image_mimetype
  image_name
  image_updatedAt
  name
  position
  product
  product_additionalTypes
  product_availableSince
  product_category
  product_createdAt
  product_description
  product_image
  product_inStock
  product_lastCheckedAt
  product_manufacturer
  product_price
  product_priceList
  product_slug
  product_soldCount
  product_status
  product_title
  product_type
  product_updatedAt
  updatedAt
}

input ProductVariantUpdateInput {
  image: ID
  name: String
  position: Int
}

type Query {
  autoBuildStatus: AutoBuildStatus!
  buildTemplates: [BuildTemplate!]!
  builds(limit: Float): [Build!]!
  currentUser: CurrentUser!
  department(id: ID!): Department!
  departments(filter: DepartmentFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [DepartmentSort!], tenant: ID!): PaginatedDepartments!
  kubernetesCronJob(name: String!): KubernetesCronJob!
  kubernetesCronJobs: [KubernetesCronJob!]!
  kubernetesJob(name: String!): KubernetesJob!
  kubernetesJobLogs(name: String!): String!
  kubernetesJobs(cronJobName: String!): [KubernetesJob!]!
  manufacturer(id: ID!): Manufacturer!
  manufacturerCountries(filter: ManufacturerCountryFilter, limit: Int! = 25, offset: Int! = 0, search: String): PaginatedManufacturerCountries!
  manufacturers(filter: ManufacturerFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ManufacturerSort!]): PaginatedManufacturers!
  product(id: ID!): Product!
  productBySlug(slug: String!): Product
  productCategories(filter: ProductCategoryFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductCategorySort!]): PaginatedProductCategories!
  productCategory(id: ID!): ProductCategory!
  productCategoryBySlug(slug: String!): ProductCategory
  productCategoryType(id: ID!): ProductCategoryType!
  productCategoryTypes(filter: ProductCategoryTypeFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductCategoryTypeSort!]): PaginatedProductCategoryTypes!
  productHighlight(id: ID!): ProductHighlight!
  productHighlights(filter: ProductHighlightFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductHighlightSort!]): PaginatedProductHighlights!
  productTag(id: ID!): ProductTag!
  productTags(filter: ProductTagFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductTagSort!]): PaginatedProductTags!
  productVariant(id: ID!): ProductVariant!
  productVariants(filter: ProductVariantFilter, limit: Int! = 25, offset: Int! = 0, product: ID!, search: String, sort: [ProductVariantSort!]): PaginatedProductVariants!
  products(filter: ProductFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [ProductSort!]): PaginatedProducts!
  tenant(id: ID!): Tenant!
  tenantUser(id: ID!): TenantUser!
  tenantUsers(filter: TenantUserFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [TenantUserSort!], tenant: ID!): PaginatedTenantUsers!
  tenants(filter: TenantFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [TenantSort!]): PaginatedTenants!
  userPermissionsAvailableContentScopes: [ContentScopeWithLabel!]!
  userPermissionsAvailablePermissions: [String!]!
  userPermissionsContentScopes(skipManual: Boolean, userId: String!): [JSONObject!]!
  userPermissionsPermission(id: ID!, userId: String): UserPermission!
  userPermissionsPermissionList(userId: String!): [UserPermission!]!
  userPermissionsUserById(id: String!): UserPermissionsUser!
  userPermissionsUsers(filter: UserPermissionsUserFilter, limit: Int! = 25, offset: Int! = 0, search: String, sort: [UserPermissionsUserSort!]): UserPermissionPaginatedUserList!
}

enum SortDirection {
  ASC
  DESC
}

input StringFilter {
  contains: String
  endsWith: String
  equal: String
  isAnyOf: [String!]
  isEmpty: Boolean
  isNotEmpty: Boolean
  notContains: String
  notEqual: String
  startsWith: String
}

type Tenant {
  createdAt: DateTime!
  departments: [Department!]!
  id: ID!
  name: String!
  updatedAt: DateTime!
}

input TenantFilter {
  and: [TenantFilter!]
  createdAt: DateTimeFilter
  departments: OneToManyFilter
  id: IdFilter
  name: StringFilter
  or: [TenantFilter!]
  updatedAt: DateTimeFilter
}

input TenantInput {
  name: String!
}

input TenantSort {
  direction: SortDirection! = ASC
  field: TenantSortField!
}

enum TenantSortField {
  createdAt
  name
  updatedAt
}

input TenantUpdateInput {
  name: String
}

type TenantUser {
  id: ID!
  tenant: Tenant!
  userId: String!
  userName: String!
}

input TenantUserFilter {
  and: [TenantUserFilter!]
  id: IdFilter
  or: [TenantUserFilter!]
  userId: StringFilter
}

input TenantUserSort {
  direction: SortDirection! = ASC
  field: TenantUserSortField!
}

enum TenantUserSortField {
  tenant
  tenant_createdAt
  tenant_name
  tenant_updatedAt
  userId
}

input UserContentScopesInput {
  contentScopes: [JSONObject!]! = []
}

type UserPermission {
  approvedBy: String
  contentScopes: [JSONObject!]!
  id: ID!
  overrideContentScopes: Boolean!
  permission: Permission!
  reason: String
  requestedBy: String
  source: UserPermissionSource!
  validFrom: DateTime
  validTo: DateTime
}

input UserPermissionInput {
  approvedBy: String
  permission: Permission!
  reason: String
  requestedBy: String
  validFrom: DateTime
  validTo: DateTime
}

input UserPermissionOverrideContentScopesInput {
  contentScopes: [JSONObject!]! = []
  overrideContentScopes: Boolean!
  permissionId: ID!
}

type UserPermissionPaginatedUserList {
  nodes: [UserPermissionsUser!]!
  totalCount: Int!
}

enum UserPermissionSource {
  BY_RULE
  MANUAL
}

type UserPermissionsUser {
  contentScopesCount: Int!
  email: String!
  id: String!
  impersonationAllowed: Boolean!
  name: String!
  permissionsCount: Int!
}

input UserPermissionsUserFilter {
  and: [UserPermissionsUserFilter!]
  email: StringFilter
  name: StringFilter
  or: [UserPermissionsUserFilter!]
  permission: PermissionFilter
  status: StringFilter
}

input UserPermissionsUserSort {
  direction: SortDirection! = ASC
  field: UserPermissionsUserSortField!
}

enum UserPermissionsUserSortField {
  email
  name
  status
}

type Warning {
  createdAt: DateTime!
  id: ID!
  message: String!
  scope: JSONObject
  severity: WarningSeverity!
  sourceInfo: WarningSourceInfo!
  status: WarningStatus!
  updatedAt: DateTime!
}

enum WarningSeverity {
  high
  low
  medium
}

type WarningSourceInfo {
  jsonPath: String
  rootColumnName: String
  rootEntityName: String!
  rootPrimaryKey: String!
  targetId: String!
}

input WarningSourceInfoInput {
  jsonPath: String
  rootColumnName: String
  rootEntityName: String!
  rootPrimaryKey: String!
  targetId: String!
}

enum WarningStatus {
  ignored
  open
  resolved
}